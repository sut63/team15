// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team15/app/ent/cleanername"
	"github.com/team15/app/ent/cleaningroom"
	"github.com/team15/app/ent/deposit"
	"github.com/team15/app/ent/employee"
	"github.com/team15/app/ent/equipment"
	"github.com/team15/app/ent/facilitie"
	"github.com/team15/app/ent/jobposition"
	"github.com/team15/app/ent/lease"
	"github.com/team15/app/ent/lengthtime"
	"github.com/team15/app/ent/nearbyplace"
	"github.com/team15/app/ent/quantity"
	"github.com/team15/app/ent/roomdetail"
	"github.com/team15/app/ent/statusd"
	"github.com/team15/app/ent/staytype"
	"github.com/team15/app/ent/wifi"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCleanerName  = "CleanerName"
	TypeCleaningRoom = "CleaningRoom"
	TypeDeposit      = "Deposit"
	TypeEmployee     = "Employee"
	TypeEquipment    = "Equipment"
	TypeFacilitie    = "Facilitie"
	TypeJobposition  = "Jobposition"
	TypeLease        = "Lease"
	TypeLengthTime   = "LengthTime"
	TypeNearbyplace  = "Nearbyplace"
	TypeQuantity     = "Quantity"
	TypeRoomdetail   = "Roomdetail"
	TypeStatusd      = "Statusd"
	TypeStaytype     = "Staytype"
	TypeWifi         = "Wifi"
)

// CleanerNameMutation represents an operation that mutate the CleanerNames
// nodes in the graph.
type CleanerNameMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	cleanername          *string
	clearedFields        map[string]struct{}
	cleaningrooms        map[int]struct{}
	removedcleaningrooms map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*CleanerName, error)
}

var _ ent.Mutation = (*CleanerNameMutation)(nil)

// cleanernameOption allows to manage the mutation configuration using functional options.
type cleanernameOption func(*CleanerNameMutation)

// newCleanerNameMutation creates new mutation for $n.Name.
func newCleanerNameMutation(c config, op Op, opts ...cleanernameOption) *CleanerNameMutation {
	m := &CleanerNameMutation{
		config:        c,
		op:            op,
		typ:           TypeCleanerName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCleanerNameID sets the id field of the mutation.
func withCleanerNameID(id int) cleanernameOption {
	return func(m *CleanerNameMutation) {
		var (
			err   error
			once  sync.Once
			value *CleanerName
		)
		m.oldValue = func(ctx context.Context) (*CleanerName, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CleanerName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCleanerName sets the old CleanerName of the mutation.
func withCleanerName(node *CleanerName) cleanernameOption {
	return func(m *CleanerNameMutation) {
		m.oldValue = func(context.Context) (*CleanerName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CleanerNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CleanerNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CleanerNameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCleanername sets the cleanername field.
func (m *CleanerNameMutation) SetCleanername(s string) {
	m.cleanername = &s
}

// Cleanername returns the cleanername value in the mutation.
func (m *CleanerNameMutation) Cleanername() (r string, exists bool) {
	v := m.cleanername
	if v == nil {
		return
	}
	return *v, true
}

// OldCleanername returns the old cleanername value of the CleanerName.
// If the CleanerName object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleanerNameMutation) OldCleanername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCleanername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCleanername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCleanername: %w", err)
	}
	return oldValue.Cleanername, nil
}

// ResetCleanername reset all changes of the "cleanername" field.
func (m *CleanerNameMutation) ResetCleanername() {
	m.cleanername = nil
}

// AddCleaningroomIDs adds the cleaningrooms edge to CleaningRoom by ids.
func (m *CleanerNameMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to CleaningRoom by ids.
func (m *CleanerNameMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *CleanerNameMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *CleanerNameMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *CleanerNameMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *CleanerNameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CleanerName).
func (m *CleanerNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CleanerNameMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.cleanername != nil {
		fields = append(fields, cleanername.FieldCleanername)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CleanerNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cleanername.FieldCleanername:
		return m.Cleanername()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CleanerNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cleanername.FieldCleanername:
		return m.OldCleanername(ctx)
	}
	return nil, fmt.Errorf("unknown CleanerName field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleanerNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cleanername.FieldCleanername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCleanername(v)
		return nil
	}
	return fmt.Errorf("unknown CleanerName field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CleanerNameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CleanerNameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleanerNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CleanerName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CleanerNameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CleanerNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CleanerNameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CleanerName nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CleanerNameMutation) ResetField(name string) error {
	switch name {
	case cleanername.FieldCleanername:
		m.ResetCleanername()
		return nil
	}
	return fmt.Errorf("unknown CleanerName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CleanerNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleaningrooms != nil {
		edges = append(edges, cleanername.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CleanerNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cleanername.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CleanerNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcleaningrooms != nil {
		edges = append(edges, cleanername.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CleanerNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cleanername.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CleanerNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CleanerNameMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CleanerNameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CleanerName unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CleanerNameMutation) ResetEdge(name string) error {
	switch name {
	case cleanername.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown CleanerName edge %s", name)
}

// CleaningRoomMutation represents an operation that mutate the CleaningRooms
// nodes in the graph.
type CleaningRoomMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	dateandstarttime    *time.Time
	note                *string
	clearedFields       map[string]struct{}
	_CleanerName        *int
	cleared_CleanerName bool
	_LengthTime         *int
	cleared_LengthTime  bool
	done                bool
	oldValue            func(context.Context) (*CleaningRoom, error)
}

var _ ent.Mutation = (*CleaningRoomMutation)(nil)

// cleaningroomOption allows to manage the mutation configuration using functional options.
type cleaningroomOption func(*CleaningRoomMutation)

// newCleaningRoomMutation creates new mutation for $n.Name.
func newCleaningRoomMutation(c config, op Op, opts ...cleaningroomOption) *CleaningRoomMutation {
	m := &CleaningRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeCleaningRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCleaningRoomID sets the id field of the mutation.
func withCleaningRoomID(id int) cleaningroomOption {
	return func(m *CleaningRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *CleaningRoom
		)
		m.oldValue = func(ctx context.Context) (*CleaningRoom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CleaningRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCleaningRoom sets the old CleaningRoom of the mutation.
func withCleaningRoom(node *CleaningRoom) cleaningroomOption {
	return func(m *CleaningRoomMutation) {
		m.oldValue = func(context.Context) (*CleaningRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CleaningRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CleaningRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CleaningRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDateandstarttime sets the dateandstarttime field.
func (m *CleaningRoomMutation) SetDateandstarttime(t time.Time) {
	m.dateandstarttime = &t
}

// Dateandstarttime returns the dateandstarttime value in the mutation.
func (m *CleaningRoomMutation) Dateandstarttime() (r time.Time, exists bool) {
	v := m.dateandstarttime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateandstarttime returns the old dateandstarttime value of the CleaningRoom.
// If the CleaningRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleaningRoomMutation) OldDateandstarttime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateandstarttime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateandstarttime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateandstarttime: %w", err)
	}
	return oldValue.Dateandstarttime, nil
}

// ResetDateandstarttime reset all changes of the "dateandstarttime" field.
func (m *CleaningRoomMutation) ResetDateandstarttime() {
	m.dateandstarttime = nil
}

// SetNote sets the note field.
func (m *CleaningRoomMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the note value in the mutation.
func (m *CleaningRoomMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old note value of the CleaningRoom.
// If the CleaningRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleaningRoomMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote reset all changes of the "note" field.
func (m *CleaningRoomMutation) ResetNote() {
	m.note = nil
}

// SetCleanerNameID sets the CleanerName edge to CleanerName by id.
func (m *CleaningRoomMutation) SetCleanerNameID(id int) {
	m._CleanerName = &id
}

// ClearCleanerName clears the CleanerName edge to CleanerName.
func (m *CleaningRoomMutation) ClearCleanerName() {
	m.cleared_CleanerName = true
}

// CleanerNameCleared returns if the edge CleanerName was cleared.
func (m *CleaningRoomMutation) CleanerNameCleared() bool {
	return m.cleared_CleanerName
}

// CleanerNameID returns the CleanerName id in the mutation.
func (m *CleaningRoomMutation) CleanerNameID() (id int, exists bool) {
	if m._CleanerName != nil {
		return *m._CleanerName, true
	}
	return
}

// CleanerNameIDs returns the CleanerName ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CleanerNameID instead. It exists only for internal usage by the builders.
func (m *CleaningRoomMutation) CleanerNameIDs() (ids []int) {
	if id := m._CleanerName; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCleanerName reset all changes of the "CleanerName" edge.
func (m *CleaningRoomMutation) ResetCleanerName() {
	m._CleanerName = nil
	m.cleared_CleanerName = false
}

// SetLengthTimeID sets the LengthTime edge to LengthTime by id.
func (m *CleaningRoomMutation) SetLengthTimeID(id int) {
	m._LengthTime = &id
}

// ClearLengthTime clears the LengthTime edge to LengthTime.
func (m *CleaningRoomMutation) ClearLengthTime() {
	m.cleared_LengthTime = true
}

// LengthTimeCleared returns if the edge LengthTime was cleared.
func (m *CleaningRoomMutation) LengthTimeCleared() bool {
	return m.cleared_LengthTime
}

// LengthTimeID returns the LengthTime id in the mutation.
func (m *CleaningRoomMutation) LengthTimeID() (id int, exists bool) {
	if m._LengthTime != nil {
		return *m._LengthTime, true
	}
	return
}

// LengthTimeIDs returns the LengthTime ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LengthTimeID instead. It exists only for internal usage by the builders.
func (m *CleaningRoomMutation) LengthTimeIDs() (ids []int) {
	if id := m._LengthTime; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLengthTime reset all changes of the "LengthTime" edge.
func (m *CleaningRoomMutation) ResetLengthTime() {
	m._LengthTime = nil
	m.cleared_LengthTime = false
}

// Op returns the operation name.
func (m *CleaningRoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CleaningRoom).
func (m *CleaningRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CleaningRoomMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.dateandstarttime != nil {
		fields = append(fields, cleaningroom.FieldDateandstarttime)
	}
	if m.note != nil {
		fields = append(fields, cleaningroom.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CleaningRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cleaningroom.FieldDateandstarttime:
		return m.Dateandstarttime()
	case cleaningroom.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CleaningRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cleaningroom.FieldDateandstarttime:
		return m.OldDateandstarttime(ctx)
	case cleaningroom.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown CleaningRoom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleaningRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cleaningroom.FieldDateandstarttime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateandstarttime(v)
		return nil
	case cleaningroom.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown CleaningRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CleaningRoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CleaningRoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleaningRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CleaningRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CleaningRoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CleaningRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CleaningRoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CleaningRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CleaningRoomMutation) ResetField(name string) error {
	switch name {
	case cleaningroom.FieldDateandstarttime:
		m.ResetDateandstarttime()
		return nil
	case cleaningroom.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown CleaningRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CleaningRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._CleanerName != nil {
		edges = append(edges, cleaningroom.EdgeCleanerName)
	}
	if m._LengthTime != nil {
		edges = append(edges, cleaningroom.EdgeLengthTime)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CleaningRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cleaningroom.EdgeCleanerName:
		if id := m._CleanerName; id != nil {
			return []ent.Value{*id}
		}
	case cleaningroom.EdgeLengthTime:
		if id := m._LengthTime; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CleaningRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CleaningRoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CleaningRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_CleanerName {
		edges = append(edges, cleaningroom.EdgeCleanerName)
	}
	if m.cleared_LengthTime {
		edges = append(edges, cleaningroom.EdgeLengthTime)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CleaningRoomMutation) EdgeCleared(name string) bool {
	switch name {
	case cleaningroom.EdgeCleanerName:
		return m.cleared_CleanerName
	case cleaningroom.EdgeLengthTime:
		return m.cleared_LengthTime
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CleaningRoomMutation) ClearEdge(name string) error {
	switch name {
	case cleaningroom.EdgeCleanerName:
		m.ClearCleanerName()
		return nil
	case cleaningroom.EdgeLengthTime:
		m.ClearLengthTime()
		return nil
	}
	return fmt.Errorf("unknown CleaningRoom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CleaningRoomMutation) ResetEdge(name string) error {
	switch name {
	case cleaningroom.EdgeCleanerName:
		m.ResetCleanerName()
		return nil
	case cleaningroom.EdgeLengthTime:
		m.ResetLengthTime()
		return nil
	}
	return fmt.Errorf("unknown CleaningRoom edge %s", name)
}

// DepositMutation represents an operation that mutate the Deposits
// nodes in the graph.
type DepositMutation struct {
	config
	op               Op
	typ              string
	id               *int
	addedtime        *time.Time
	info             *string
	clearedFields    map[string]struct{}
	_Employee        *int
	cleared_Employee bool
	_Statusd         *int
	cleared_Statusd  bool
	done             bool
	oldValue         func(context.Context) (*Deposit, error)
}

var _ ent.Mutation = (*DepositMutation)(nil)

// depositOption allows to manage the mutation configuration using functional options.
type depositOption func(*DepositMutation)

// newDepositMutation creates new mutation for $n.Name.
func newDepositMutation(c config, op Op, opts ...depositOption) *DepositMutation {
	m := &DepositMutation{
		config:        c,
		op:            op,
		typ:           TypeDeposit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepositID sets the id field of the mutation.
func withDepositID(id int) depositOption {
	return func(m *DepositMutation) {
		var (
			err   error
			once  sync.Once
			value *Deposit
		)
		m.oldValue = func(ctx context.Context) (*Deposit, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deposit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeposit sets the old Deposit of the mutation.
func withDeposit(node *Deposit) depositOption {
	return func(m *DepositMutation) {
		m.oldValue = func(context.Context) (*Deposit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepositMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepositMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepositMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *DepositMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *DepositMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *DepositMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetInfo sets the info field.
func (m *DepositMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the info value in the mutation.
func (m *DepositMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old info value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo reset all changes of the "info" field.
func (m *DepositMutation) ResetInfo() {
	m.info = nil
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *DepositMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *DepositMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *DepositMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *DepositMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *DepositMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *DepositMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// SetStatusdID sets the Statusd edge to Statusd by id.
func (m *DepositMutation) SetStatusdID(id int) {
	m._Statusd = &id
}

// ClearStatusd clears the Statusd edge to Statusd.
func (m *DepositMutation) ClearStatusd() {
	m.cleared_Statusd = true
}

// StatusdCleared returns if the edge Statusd was cleared.
func (m *DepositMutation) StatusdCleared() bool {
	return m.cleared_Statusd
}

// StatusdID returns the Statusd id in the mutation.
func (m *DepositMutation) StatusdID() (id int, exists bool) {
	if m._Statusd != nil {
		return *m._Statusd, true
	}
	return
}

// StatusdIDs returns the Statusd ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatusdID instead. It exists only for internal usage by the builders.
func (m *DepositMutation) StatusdIDs() (ids []int) {
	if id := m._Statusd; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusd reset all changes of the "Statusd" edge.
func (m *DepositMutation) ResetStatusd() {
	m._Statusd = nil
	m.cleared_Statusd = false
}

// Op returns the operation name.
func (m *DepositMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Deposit).
func (m *DepositMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepositMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.addedtime != nil {
		fields = append(fields, deposit.FieldAddedtime)
	}
	if m.info != nil {
		fields = append(fields, deposit.FieldInfo)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepositMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deposit.FieldAddedtime:
		return m.Addedtime()
	case deposit.FieldInfo:
		return m.Info()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepositMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deposit.FieldAddedtime:
		return m.OldAddedtime(ctx)
	case deposit.FieldInfo:
		return m.OldInfo(ctx)
	}
	return nil, fmt.Errorf("unknown Deposit field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepositMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deposit.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	case deposit.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	}
	return fmt.Errorf("unknown Deposit field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepositMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepositMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepositMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deposit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepositMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepositMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepositMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Deposit nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepositMutation) ResetField(name string) error {
	switch name {
	case deposit.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	case deposit.FieldInfo:
		m.ResetInfo()
		return nil
	}
	return fmt.Errorf("unknown Deposit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepositMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Employee != nil {
		edges = append(edges, deposit.EdgeEmployee)
	}
	if m._Statusd != nil {
		edges = append(edges, deposit.EdgeStatusd)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepositMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deposit.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	case deposit.EdgeStatusd:
		if id := m._Statusd; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepositMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepositMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepositMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Employee {
		edges = append(edges, deposit.EdgeEmployee)
	}
	if m.cleared_Statusd {
		edges = append(edges, deposit.EdgeStatusd)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepositMutation) EdgeCleared(name string) bool {
	switch name {
	case deposit.EdgeEmployee:
		return m.cleared_Employee
	case deposit.EdgeStatusd:
		return m.cleared_Statusd
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepositMutation) ClearEdge(name string) error {
	switch name {
	case deposit.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case deposit.EdgeStatusd:
		m.ClearStatusd()
		return nil
	}
	return fmt.Errorf("unknown Deposit unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepositMutation) ResetEdge(name string) error {
	switch name {
	case deposit.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case deposit.EdgeStatusd:
		m.ResetStatusd()
		return nil
	}
	return fmt.Errorf("unknown Deposit edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	email              *string
	password           *string
	clearedFields      map[string]struct{}
	employees          map[int]struct{}
	removedemployees   map[int]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	jobposition        *int
	clearedjobposition bool
	done               bool
	oldValue           func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *EmployeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EmployeeMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *EmployeeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *EmployeeMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *EmployeeMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *EmployeeMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *EmployeeMutation) ResetPassword() {
	m.password = nil
}

// AddEmployeeIDs adds the employees edge to Deposit by ids.
func (m *EmployeeMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Deposit by ids.
func (m *EmployeeMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *EmployeeMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *EmployeeMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *EmployeeMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *EmployeeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *EmployeeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *EmployeeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *EmployeeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *EmployeeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// SetJobpositionID sets the jobposition edge to Jobposition by id.
func (m *EmployeeMutation) SetJobpositionID(id int) {
	m.jobposition = &id
}

// ClearJobposition clears the jobposition edge to Jobposition.
func (m *EmployeeMutation) ClearJobposition() {
	m.clearedjobposition = true
}

// JobpositionCleared returns if the edge jobposition was cleared.
func (m *EmployeeMutation) JobpositionCleared() bool {
	return m.clearedjobposition
}

// JobpositionID returns the jobposition id in the mutation.
func (m *EmployeeMutation) JobpositionID() (id int, exists bool) {
	if m.jobposition != nil {
		return *m.jobposition, true
	}
	return
}

// JobpositionIDs returns the jobposition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// JobpositionID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) JobpositionIDs() (ids []int) {
	if id := m.jobposition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobposition reset all changes of the "jobposition" edge.
func (m *EmployeeMutation) ResetJobposition() {
	m.jobposition = nil
	m.clearedjobposition = false
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, employee.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldName:
		return m.Name()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.employees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	if m.roomdetails != nil {
		edges = append(edges, employee.EdgeRoomdetails)
	}
	if m.jobposition != nil {
		edges = append(edges, employee.EdgeJobposition)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeJobposition:
		if id := m.jobposition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedemployees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	if m.removedroomdetails != nil {
		edges = append(edges, employee.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedjobposition {
		edges = append(edges, employee.EdgeJobposition)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeJobposition:
		return m.clearedjobposition
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeJobposition:
		m.ClearJobposition()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case employee.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	case employee.EdgeJobposition:
		m.ResetJobposition()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// EquipmentMutation represents an operation that mutate the EquipmentSlice
// nodes in the graph.
type EquipmentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	equipment         *string
	clearedFields     map[string]struct{}
	roomdetail        map[int]struct{}
	removedroomdetail map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Equipment, error)
}

var _ ent.Mutation = (*EquipmentMutation)(nil)

// equipmentOption allows to manage the mutation configuration using functional options.
type equipmentOption func(*EquipmentMutation)

// newEquipmentMutation creates new mutation for $n.Name.
func newEquipmentMutation(c config, op Op, opts ...equipmentOption) *EquipmentMutation {
	m := &EquipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentID sets the id field of the mutation.
func withEquipmentID(id int) equipmentOption {
	return func(m *EquipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipment
		)
		m.oldValue = func(ctx context.Context) (*Equipment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipment sets the old Equipment of the mutation.
func withEquipment(node *Equipment) equipmentOption {
	return func(m *EquipmentMutation) {
		m.oldValue = func(context.Context) (*Equipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEquipment sets the equipment field.
func (m *EquipmentMutation) SetEquipment(s string) {
	m.equipment = &s
}

// Equipment returns the equipment value in the mutation.
func (m *EquipmentMutation) Equipment() (r string, exists bool) {
	v := m.equipment
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipment returns the old equipment value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldEquipment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEquipment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEquipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipment: %w", err)
	}
	return oldValue.Equipment, nil
}

// ResetEquipment reset all changes of the "equipment" field.
func (m *EquipmentMutation) ResetEquipment() {
	m.equipment = nil
}

// AddRoomdetailIDs adds the roomdetail edge to Roomdetail by ids.
func (m *EquipmentMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetail == nil {
		m.roomdetail = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetail[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetail edge to Roomdetail by ids.
func (m *EquipmentMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetail == nil {
		m.removedroomdetail = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetail[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetail returns the removed ids of roomdetail.
func (m *EquipmentMutation) RemovedRoomdetailIDs() (ids []int) {
	for id := range m.removedroomdetail {
		ids = append(ids, id)
	}
	return
}

// RoomdetailIDs returns the roomdetail ids in the mutation.
func (m *EquipmentMutation) RoomdetailIDs() (ids []int) {
	for id := range m.roomdetail {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetail reset all changes of the "roomdetail" edge.
func (m *EquipmentMutation) ResetRoomdetail() {
	m.roomdetail = nil
	m.removedroomdetail = nil
}

// Op returns the operation name.
func (m *EquipmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Equipment).
func (m *EquipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.equipment != nil {
		fields = append(fields, equipment.FieldEquipment)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldEquipment:
		return m.Equipment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipment.FieldEquipment:
		return m.OldEquipment(ctx)
	}
	return nil, fmt.Errorf("unknown Equipment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldEquipment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipment(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Equipment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentMutation) ResetField(name string) error {
	switch name {
	case equipment.FieldEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetail != nil {
		edges = append(edges, equipment.EdgeRoomdetail)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeRoomdetail:
		ids := make([]ent.Value, 0, len(m.roomdetail))
		for id := range m.roomdetail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetail != nil {
		edges = append(edges, equipment.EdgeRoomdetail)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeRoomdetail:
		ids := make([]ent.Value, 0, len(m.removedroomdetail))
		for id := range m.removedroomdetail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentMutation) ResetEdge(name string) error {
	switch name {
	case equipment.EdgeRoomdetail:
		m.ResetRoomdetail()
		return nil
	}
	return fmt.Errorf("unknown Equipment edge %s", name)
}

// FacilitieMutation represents an operation that mutate the Facilities
// nodes in the graph.
type FacilitieMutation struct {
	config
	op                Op
	typ               string
	id                *int
	facilitie         *string
	clearedFields     map[string]struct{}
	roomdetail        map[int]struct{}
	removedroomdetail map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Facilitie, error)
}

var _ ent.Mutation = (*FacilitieMutation)(nil)

// facilitieOption allows to manage the mutation configuration using functional options.
type facilitieOption func(*FacilitieMutation)

// newFacilitieMutation creates new mutation for $n.Name.
func newFacilitieMutation(c config, op Op, opts ...facilitieOption) *FacilitieMutation {
	m := &FacilitieMutation{
		config:        c,
		op:            op,
		typ:           TypeFacilitie,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacilitieID sets the id field of the mutation.
func withFacilitieID(id int) facilitieOption {
	return func(m *FacilitieMutation) {
		var (
			err   error
			once  sync.Once
			value *Facilitie
		)
		m.oldValue = func(ctx context.Context) (*Facilitie, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Facilitie.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFacilitie sets the old Facilitie of the mutation.
func withFacilitie(node *Facilitie) facilitieOption {
	return func(m *FacilitieMutation) {
		m.oldValue = func(context.Context) (*Facilitie, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacilitieMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacilitieMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FacilitieMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFacilitie sets the facilitie field.
func (m *FacilitieMutation) SetFacilitie(s string) {
	m.facilitie = &s
}

// Facilitie returns the facilitie value in the mutation.
func (m *FacilitieMutation) Facilitie() (r string, exists bool) {
	v := m.facilitie
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilitie returns the old facilitie value of the Facilitie.
// If the Facilitie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FacilitieMutation) OldFacilitie(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFacilitie is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFacilitie requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilitie: %w", err)
	}
	return oldValue.Facilitie, nil
}

// ResetFacilitie reset all changes of the "facilitie" field.
func (m *FacilitieMutation) ResetFacilitie() {
	m.facilitie = nil
}

// AddRoomdetailIDs adds the roomdetail edge to Roomdetail by ids.
func (m *FacilitieMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetail == nil {
		m.roomdetail = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetail[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetail edge to Roomdetail by ids.
func (m *FacilitieMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetail == nil {
		m.removedroomdetail = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetail[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetail returns the removed ids of roomdetail.
func (m *FacilitieMutation) RemovedRoomdetailIDs() (ids []int) {
	for id := range m.removedroomdetail {
		ids = append(ids, id)
	}
	return
}

// RoomdetailIDs returns the roomdetail ids in the mutation.
func (m *FacilitieMutation) RoomdetailIDs() (ids []int) {
	for id := range m.roomdetail {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetail reset all changes of the "roomdetail" edge.
func (m *FacilitieMutation) ResetRoomdetail() {
	m.roomdetail = nil
	m.removedroomdetail = nil
}

// Op returns the operation name.
func (m *FacilitieMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Facilitie).
func (m *FacilitieMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FacilitieMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.facilitie != nil {
		fields = append(fields, facilitie.FieldFacilitie)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FacilitieMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case facilitie.FieldFacilitie:
		return m.Facilitie()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FacilitieMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case facilitie.FieldFacilitie:
		return m.OldFacilitie(ctx)
	}
	return nil, fmt.Errorf("unknown Facilitie field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacilitieMutation) SetField(name string, value ent.Value) error {
	switch name {
	case facilitie.FieldFacilitie:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilitie(v)
		return nil
	}
	return fmt.Errorf("unknown Facilitie field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FacilitieMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FacilitieMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacilitieMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Facilitie numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FacilitieMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FacilitieMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacilitieMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Facilitie nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FacilitieMutation) ResetField(name string) error {
	switch name {
	case facilitie.FieldFacilitie:
		m.ResetFacilitie()
		return nil
	}
	return fmt.Errorf("unknown Facilitie field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FacilitieMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetail != nil {
		edges = append(edges, facilitie.EdgeRoomdetail)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FacilitieMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case facilitie.EdgeRoomdetail:
		ids := make([]ent.Value, 0, len(m.roomdetail))
		for id := range m.roomdetail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FacilitieMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetail != nil {
		edges = append(edges, facilitie.EdgeRoomdetail)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FacilitieMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case facilitie.EdgeRoomdetail:
		ids := make([]ent.Value, 0, len(m.removedroomdetail))
		for id := range m.removedroomdetail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FacilitieMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FacilitieMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FacilitieMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Facilitie unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FacilitieMutation) ResetEdge(name string) error {
	switch name {
	case facilitie.EdgeRoomdetail:
		m.ResetRoomdetail()
		return nil
	}
	return fmt.Errorf("unknown Facilitie edge %s", name)
}

// JobpositionMutation represents an operation that mutate the Jobpositions
// nodes in the graph.
type JobpositionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	position_name    *string
	clearedFields    map[string]struct{}
	employees        map[int]struct{}
	removedemployees map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Jobposition, error)
}

var _ ent.Mutation = (*JobpositionMutation)(nil)

// jobpositionOption allows to manage the mutation configuration using functional options.
type jobpositionOption func(*JobpositionMutation)

// newJobpositionMutation creates new mutation for $n.Name.
func newJobpositionMutation(c config, op Op, opts ...jobpositionOption) *JobpositionMutation {
	m := &JobpositionMutation{
		config:        c,
		op:            op,
		typ:           TypeJobposition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobpositionID sets the id field of the mutation.
func withJobpositionID(id int) jobpositionOption {
	return func(m *JobpositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Jobposition
		)
		m.oldValue = func(ctx context.Context) (*Jobposition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Jobposition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobposition sets the old Jobposition of the mutation.
func withJobposition(node *Jobposition) jobpositionOption {
	return func(m *JobpositionMutation) {
		m.oldValue = func(context.Context) (*Jobposition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobpositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobpositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *JobpositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPositionName sets the position_name field.
func (m *JobpositionMutation) SetPositionName(s string) {
	m.position_name = &s
}

// PositionName returns the position_name value in the mutation.
func (m *JobpositionMutation) PositionName() (r string, exists bool) {
	v := m.position_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionName returns the old position_name value of the Jobposition.
// If the Jobposition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *JobpositionMutation) OldPositionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionName: %w", err)
	}
	return oldValue.PositionName, nil
}

// ResetPositionName reset all changes of the "position_name" field.
func (m *JobpositionMutation) ResetPositionName() {
	m.position_name = nil
}

// AddEmployeeIDs adds the employees edge to Employee by ids.
func (m *JobpositionMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Employee by ids.
func (m *JobpositionMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *JobpositionMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *JobpositionMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *JobpositionMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// Op returns the operation name.
func (m *JobpositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Jobposition).
func (m *JobpositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *JobpositionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.position_name != nil {
		fields = append(fields, jobposition.FieldPositionName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *JobpositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobposition.FieldPositionName:
		return m.PositionName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *JobpositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobposition.FieldPositionName:
		return m.OldPositionName(ctx)
	}
	return nil, fmt.Errorf("unknown Jobposition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *JobpositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobposition.FieldPositionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionName(v)
		return nil
	}
	return fmt.Errorf("unknown Jobposition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *JobpositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *JobpositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *JobpositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Jobposition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *JobpositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *JobpositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobpositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Jobposition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *JobpositionMutation) ResetField(name string) error {
	switch name {
	case jobposition.FieldPositionName:
		m.ResetPositionName()
		return nil
	}
	return fmt.Errorf("unknown Jobposition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *JobpositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employees != nil {
		edges = append(edges, jobposition.EdgeEmployees)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *JobpositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *JobpositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployees != nil {
		edges = append(edges, jobposition.EdgeEmployees)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *JobpositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *JobpositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *JobpositionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *JobpositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Jobposition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *JobpositionMutation) ResetEdge(name string) error {
	switch name {
	case jobposition.EdgeEmployees:
		m.ResetEmployees()
		return nil
	}
	return fmt.Errorf("unknown Jobposition edge %s", name)
}

// LeaseMutation represents an operation that mutate the Leases
// nodes in the graph.
type LeaseMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	addedtime          *time.Time
	tenant             *string
	clearedFields      map[string]struct{}
	_Wifi              *int
	cleared_Wifi       bool
	_Roomdetail        *int
	cleared_Roomdetail bool
	done               bool
	oldValue           func(context.Context) (*Lease, error)
}

var _ ent.Mutation = (*LeaseMutation)(nil)

// leaseOption allows to manage the mutation configuration using functional options.
type leaseOption func(*LeaseMutation)

// newLeaseMutation creates new mutation for $n.Name.
func newLeaseMutation(c config, op Op, opts ...leaseOption) *LeaseMutation {
	m := &LeaseMutation{
		config:        c,
		op:            op,
		typ:           TypeLease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeaseID sets the id field of the mutation.
func withLeaseID(id int) leaseOption {
	return func(m *LeaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Lease
		)
		m.oldValue = func(ctx context.Context) (*Lease, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLease sets the old Lease of the mutation.
func withLease(node *Lease) leaseOption {
	return func(m *LeaseMutation) {
		m.oldValue = func(context.Context) (*Lease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LeaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *LeaseMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *LeaseMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Lease.
// If the Lease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LeaseMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *LeaseMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetTenant sets the tenant field.
func (m *LeaseMutation) SetTenant(s string) {
	m.tenant = &s
}

// Tenant returns the tenant value in the mutation.
func (m *LeaseMutation) Tenant() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenant returns the old tenant value of the Lease.
// If the Lease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LeaseMutation) OldTenant(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenant is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenant: %w", err)
	}
	return oldValue.Tenant, nil
}

// ResetTenant reset all changes of the "tenant" field.
func (m *LeaseMutation) ResetTenant() {
	m.tenant = nil
}

// SetWifiID sets the Wifi edge to Wifi by id.
func (m *LeaseMutation) SetWifiID(id int) {
	m._Wifi = &id
}

// ClearWifi clears the Wifi edge to Wifi.
func (m *LeaseMutation) ClearWifi() {
	m.cleared_Wifi = true
}

// WifiCleared returns if the edge Wifi was cleared.
func (m *LeaseMutation) WifiCleared() bool {
	return m.cleared_Wifi
}

// WifiID returns the Wifi id in the mutation.
func (m *LeaseMutation) WifiID() (id int, exists bool) {
	if m._Wifi != nil {
		return *m._Wifi, true
	}
	return
}

// WifiIDs returns the Wifi ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WifiID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) WifiIDs() (ids []int) {
	if id := m._Wifi; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWifi reset all changes of the "Wifi" edge.
func (m *LeaseMutation) ResetWifi() {
	m._Wifi = nil
	m.cleared_Wifi = false
}

// SetRoomdetailID sets the Roomdetail edge to Roomdetail by id.
func (m *LeaseMutation) SetRoomdetailID(id int) {
	m._Roomdetail = &id
}

// ClearRoomdetail clears the Roomdetail edge to Roomdetail.
func (m *LeaseMutation) ClearRoomdetail() {
	m.cleared_Roomdetail = true
}

// RoomdetailCleared returns if the edge Roomdetail was cleared.
func (m *LeaseMutation) RoomdetailCleared() bool {
	return m.cleared_Roomdetail
}

// RoomdetailID returns the Roomdetail id in the mutation.
func (m *LeaseMutation) RoomdetailID() (id int, exists bool) {
	if m._Roomdetail != nil {
		return *m._Roomdetail, true
	}
	return
}

// RoomdetailIDs returns the Roomdetail ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomdetailID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) RoomdetailIDs() (ids []int) {
	if id := m._Roomdetail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomdetail reset all changes of the "Roomdetail" edge.
func (m *LeaseMutation) ResetRoomdetail() {
	m._Roomdetail = nil
	m.cleared_Roomdetail = false
}

// Op returns the operation name.
func (m *LeaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Lease).
func (m *LeaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LeaseMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.addedtime != nil {
		fields = append(fields, lease.FieldAddedtime)
	}
	if m.tenant != nil {
		fields = append(fields, lease.FieldTenant)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LeaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lease.FieldAddedtime:
		return m.Addedtime()
	case lease.FieldTenant:
		return m.Tenant()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LeaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lease.FieldAddedtime:
		return m.OldAddedtime(ctx)
	case lease.FieldTenant:
		return m.OldTenant(ctx)
	}
	return nil, fmt.Errorf("unknown Lease field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LeaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lease.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	case lease.FieldTenant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenant(v)
		return nil
	}
	return fmt.Errorf("unknown Lease field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LeaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LeaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LeaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Lease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LeaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LeaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Lease nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LeaseMutation) ResetField(name string) error {
	switch name {
	case lease.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	case lease.FieldTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Lease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LeaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Wifi != nil {
		edges = append(edges, lease.EdgeWifi)
	}
	if m._Roomdetail != nil {
		edges = append(edges, lease.EdgeRoomdetail)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LeaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lease.EdgeWifi:
		if id := m._Wifi; id != nil {
			return []ent.Value{*id}
		}
	case lease.EdgeRoomdetail:
		if id := m._Roomdetail; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LeaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LeaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LeaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Wifi {
		edges = append(edges, lease.EdgeWifi)
	}
	if m.cleared_Roomdetail {
		edges = append(edges, lease.EdgeRoomdetail)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LeaseMutation) EdgeCleared(name string) bool {
	switch name {
	case lease.EdgeWifi:
		return m.cleared_Wifi
	case lease.EdgeRoomdetail:
		return m.cleared_Roomdetail
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LeaseMutation) ClearEdge(name string) error {
	switch name {
	case lease.EdgeWifi:
		m.ClearWifi()
		return nil
	case lease.EdgeRoomdetail:
		m.ClearRoomdetail()
		return nil
	}
	return fmt.Errorf("unknown Lease unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LeaseMutation) ResetEdge(name string) error {
	switch name {
	case lease.EdgeWifi:
		m.ResetWifi()
		return nil
	case lease.EdgeRoomdetail:
		m.ResetRoomdetail()
		return nil
	}
	return fmt.Errorf("unknown Lease edge %s", name)
}

// LengthTimeMutation represents an operation that mutate the LengthTimes
// nodes in the graph.
type LengthTimeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	lengthtime           *string
	clearedFields        map[string]struct{}
	cleaningrooms        map[int]struct{}
	removedcleaningrooms map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*LengthTime, error)
}

var _ ent.Mutation = (*LengthTimeMutation)(nil)

// lengthtimeOption allows to manage the mutation configuration using functional options.
type lengthtimeOption func(*LengthTimeMutation)

// newLengthTimeMutation creates new mutation for $n.Name.
func newLengthTimeMutation(c config, op Op, opts ...lengthtimeOption) *LengthTimeMutation {
	m := &LengthTimeMutation{
		config:        c,
		op:            op,
		typ:           TypeLengthTime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLengthTimeID sets the id field of the mutation.
func withLengthTimeID(id int) lengthtimeOption {
	return func(m *LengthTimeMutation) {
		var (
			err   error
			once  sync.Once
			value *LengthTime
		)
		m.oldValue = func(ctx context.Context) (*LengthTime, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LengthTime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLengthTime sets the old LengthTime of the mutation.
func withLengthTime(node *LengthTime) lengthtimeOption {
	return func(m *LengthTimeMutation) {
		m.oldValue = func(context.Context) (*LengthTime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LengthTimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LengthTimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LengthTimeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLengthtime sets the lengthtime field.
func (m *LengthTimeMutation) SetLengthtime(s string) {
	m.lengthtime = &s
}

// Lengthtime returns the lengthtime value in the mutation.
func (m *LengthTimeMutation) Lengthtime() (r string, exists bool) {
	v := m.lengthtime
	if v == nil {
		return
	}
	return *v, true
}

// OldLengthtime returns the old lengthtime value of the LengthTime.
// If the LengthTime object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LengthTimeMutation) OldLengthtime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLengthtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLengthtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLengthtime: %w", err)
	}
	return oldValue.Lengthtime, nil
}

// ResetLengthtime reset all changes of the "lengthtime" field.
func (m *LengthTimeMutation) ResetLengthtime() {
	m.lengthtime = nil
}

// AddCleaningroomIDs adds the cleaningrooms edge to CleaningRoom by ids.
func (m *LengthTimeMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to CleaningRoom by ids.
func (m *LengthTimeMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *LengthTimeMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *LengthTimeMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *LengthTimeMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *LengthTimeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LengthTime).
func (m *LengthTimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LengthTimeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.lengthtime != nil {
		fields = append(fields, lengthtime.FieldLengthtime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LengthTimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lengthtime.FieldLengthtime:
		return m.Lengthtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LengthTimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lengthtime.FieldLengthtime:
		return m.OldLengthtime(ctx)
	}
	return nil, fmt.Errorf("unknown LengthTime field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LengthTimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lengthtime.FieldLengthtime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLengthtime(v)
		return nil
	}
	return fmt.Errorf("unknown LengthTime field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LengthTimeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LengthTimeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LengthTimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LengthTime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LengthTimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LengthTimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LengthTimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LengthTime nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LengthTimeMutation) ResetField(name string) error {
	switch name {
	case lengthtime.FieldLengthtime:
		m.ResetLengthtime()
		return nil
	}
	return fmt.Errorf("unknown LengthTime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LengthTimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleaningrooms != nil {
		edges = append(edges, lengthtime.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LengthTimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lengthtime.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LengthTimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcleaningrooms != nil {
		edges = append(edges, lengthtime.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LengthTimeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lengthtime.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LengthTimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LengthTimeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LengthTimeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LengthTime unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LengthTimeMutation) ResetEdge(name string) error {
	switch name {
	case lengthtime.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown LengthTime edge %s", name)
}

// NearbyplaceMutation represents an operation that mutate the Nearbyplaces
// nodes in the graph.
type NearbyplaceMutation struct {
	config
	op                Op
	typ               string
	id                *int
	nearbyplace       *string
	clearedFields     map[string]struct{}
	roomdetail        map[int]struct{}
	removedroomdetail map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Nearbyplace, error)
}

var _ ent.Mutation = (*NearbyplaceMutation)(nil)

// nearbyplaceOption allows to manage the mutation configuration using functional options.
type nearbyplaceOption func(*NearbyplaceMutation)

// newNearbyplaceMutation creates new mutation for $n.Name.
func newNearbyplaceMutation(c config, op Op, opts ...nearbyplaceOption) *NearbyplaceMutation {
	m := &NearbyplaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNearbyplace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNearbyplaceID sets the id field of the mutation.
func withNearbyplaceID(id int) nearbyplaceOption {
	return func(m *NearbyplaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Nearbyplace
		)
		m.oldValue = func(ctx context.Context) (*Nearbyplace, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nearbyplace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNearbyplace sets the old Nearbyplace of the mutation.
func withNearbyplace(node *Nearbyplace) nearbyplaceOption {
	return func(m *NearbyplaceMutation) {
		m.oldValue = func(context.Context) (*Nearbyplace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NearbyplaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NearbyplaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *NearbyplaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNearbyplace sets the nearbyplace field.
func (m *NearbyplaceMutation) SetNearbyplace(s string) {
	m.nearbyplace = &s
}

// Nearbyplace returns the nearbyplace value in the mutation.
func (m *NearbyplaceMutation) Nearbyplace() (r string, exists bool) {
	v := m.nearbyplace
	if v == nil {
		return
	}
	return *v, true
}

// OldNearbyplace returns the old nearbyplace value of the Nearbyplace.
// If the Nearbyplace object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NearbyplaceMutation) OldNearbyplace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNearbyplace is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNearbyplace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNearbyplace: %w", err)
	}
	return oldValue.Nearbyplace, nil
}

// ResetNearbyplace reset all changes of the "nearbyplace" field.
func (m *NearbyplaceMutation) ResetNearbyplace() {
	m.nearbyplace = nil
}

// AddRoomdetailIDs adds the roomdetail edge to Roomdetail by ids.
func (m *NearbyplaceMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetail == nil {
		m.roomdetail = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetail[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetail edge to Roomdetail by ids.
func (m *NearbyplaceMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetail == nil {
		m.removedroomdetail = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetail[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetail returns the removed ids of roomdetail.
func (m *NearbyplaceMutation) RemovedRoomdetailIDs() (ids []int) {
	for id := range m.removedroomdetail {
		ids = append(ids, id)
	}
	return
}

// RoomdetailIDs returns the roomdetail ids in the mutation.
func (m *NearbyplaceMutation) RoomdetailIDs() (ids []int) {
	for id := range m.roomdetail {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetail reset all changes of the "roomdetail" edge.
func (m *NearbyplaceMutation) ResetRoomdetail() {
	m.roomdetail = nil
	m.removedroomdetail = nil
}

// Op returns the operation name.
func (m *NearbyplaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Nearbyplace).
func (m *NearbyplaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *NearbyplaceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.nearbyplace != nil {
		fields = append(fields, nearbyplace.FieldNearbyplace)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *NearbyplaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nearbyplace.FieldNearbyplace:
		return m.Nearbyplace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *NearbyplaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nearbyplace.FieldNearbyplace:
		return m.OldNearbyplace(ctx)
	}
	return nil, fmt.Errorf("unknown Nearbyplace field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NearbyplaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nearbyplace.FieldNearbyplace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNearbyplace(v)
		return nil
	}
	return fmt.Errorf("unknown Nearbyplace field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *NearbyplaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *NearbyplaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NearbyplaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nearbyplace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *NearbyplaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *NearbyplaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *NearbyplaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nearbyplace nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *NearbyplaceMutation) ResetField(name string) error {
	switch name {
	case nearbyplace.FieldNearbyplace:
		m.ResetNearbyplace()
		return nil
	}
	return fmt.Errorf("unknown Nearbyplace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *NearbyplaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetail != nil {
		edges = append(edges, nearbyplace.EdgeRoomdetail)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *NearbyplaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nearbyplace.EdgeRoomdetail:
		ids := make([]ent.Value, 0, len(m.roomdetail))
		for id := range m.roomdetail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *NearbyplaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetail != nil {
		edges = append(edges, nearbyplace.EdgeRoomdetail)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *NearbyplaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nearbyplace.EdgeRoomdetail:
		ids := make([]ent.Value, 0, len(m.removedroomdetail))
		for id := range m.removedroomdetail {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *NearbyplaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *NearbyplaceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *NearbyplaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Nearbyplace unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *NearbyplaceMutation) ResetEdge(name string) error {
	switch name {
	case nearbyplace.EdgeRoomdetail:
		m.ResetRoomdetail()
		return nil
	}
	return fmt.Errorf("unknown Nearbyplace edge %s", name)
}

// QuantityMutation represents an operation that mutate the Quantities
// nodes in the graph.
type QuantityMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	quantity           *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Quantity, error)
}

var _ ent.Mutation = (*QuantityMutation)(nil)

// quantityOption allows to manage the mutation configuration using functional options.
type quantityOption func(*QuantityMutation)

// newQuantityMutation creates new mutation for $n.Name.
func newQuantityMutation(c config, op Op, opts ...quantityOption) *QuantityMutation {
	m := &QuantityMutation{
		config:        c,
		op:            op,
		typ:           TypeQuantity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuantityID sets the id field of the mutation.
func withQuantityID(id int) quantityOption {
	return func(m *QuantityMutation) {
		var (
			err   error
			once  sync.Once
			value *Quantity
		)
		m.oldValue = func(ctx context.Context) (*Quantity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Quantity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuantity sets the old Quantity of the mutation.
func withQuantity(node *Quantity) quantityOption {
	return func(m *QuantityMutation) {
		m.oldValue = func(context.Context) (*Quantity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuantityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuantityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *QuantityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetQuantity sets the quantity field.
func (m *QuantityMutation) SetQuantity(s string) {
	m.quantity = &s
}

// Quantity returns the quantity value in the mutation.
func (m *QuantityMutation) Quantity() (r string, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old quantity value of the Quantity.
// If the Quantity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *QuantityMutation) OldQuantity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity reset all changes of the "quantity" field.
func (m *QuantityMutation) ResetQuantity() {
	m.quantity = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *QuantityMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *QuantityMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *QuantityMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *QuantityMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *QuantityMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *QuantityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Quantity).
func (m *QuantityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *QuantityMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.quantity != nil {
		fields = append(fields, quantity.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *QuantityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case quantity.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *QuantityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case quantity.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown Quantity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QuantityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case quantity.FieldQuantity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Quantity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *QuantityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *QuantityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QuantityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Quantity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *QuantityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *QuantityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuantityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Quantity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *QuantityMutation) ResetField(name string) error {
	switch name {
	case quantity.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown Quantity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *QuantityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, quantity.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *QuantityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case quantity.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *QuantityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, quantity.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *QuantityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case quantity.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *QuantityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *QuantityMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *QuantityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Quantity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *QuantityMutation) ResetEdge(name string) error {
	switch name {
	case quantity.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Quantity edge %s", name)
}

// RoomdetailMutation represents an operation that mutate the Roomdetails
// nodes in the graph.
type RoomdetailMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	roomtypename        *string
	roomprice           *string
	clearedFields       map[string]struct{}
	equipments          *int
	clearedequipments   bool
	facilities          *int
	clearedfacilities   bool
	nearbyplaces        *int
	clearednearbyplaces bool
	employee            *int
	clearedemployee     bool
	quantity            *int
	clearedquantity     bool
	staytype            *int
	clearedstaytype     bool
	roomdetails         *int
	clearedroomdetails  bool
	done                bool
	oldValue            func(context.Context) (*Roomdetail, error)
}

var _ ent.Mutation = (*RoomdetailMutation)(nil)

// roomdetailOption allows to manage the mutation configuration using functional options.
type roomdetailOption func(*RoomdetailMutation)

// newRoomdetailMutation creates new mutation for $n.Name.
func newRoomdetailMutation(c config, op Op, opts ...roomdetailOption) *RoomdetailMutation {
	m := &RoomdetailMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomdetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomdetailID sets the id field of the mutation.
func withRoomdetailID(id int) roomdetailOption {
	return func(m *RoomdetailMutation) {
		var (
			err   error
			once  sync.Once
			value *Roomdetail
		)
		m.oldValue = func(ctx context.Context) (*Roomdetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Roomdetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomdetail sets the old Roomdetail of the mutation.
func withRoomdetail(node *Roomdetail) roomdetailOption {
	return func(m *RoomdetailMutation) {
		m.oldValue = func(context.Context) (*Roomdetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomdetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomdetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomdetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomtypename sets the roomtypename field.
func (m *RoomdetailMutation) SetRoomtypename(s string) {
	m.roomtypename = &s
}

// Roomtypename returns the roomtypename value in the mutation.
func (m *RoomdetailMutation) Roomtypename() (r string, exists bool) {
	v := m.roomtypename
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomtypename returns the old roomtypename value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldRoomtypename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomtypename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomtypename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomtypename: %w", err)
	}
	return oldValue.Roomtypename, nil
}

// ResetRoomtypename reset all changes of the "roomtypename" field.
func (m *RoomdetailMutation) ResetRoomtypename() {
	m.roomtypename = nil
}

// SetRoomprice sets the roomprice field.
func (m *RoomdetailMutation) SetRoomprice(s string) {
	m.roomprice = &s
}

// Roomprice returns the roomprice value in the mutation.
func (m *RoomdetailMutation) Roomprice() (r string, exists bool) {
	v := m.roomprice
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomprice returns the old roomprice value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldRoomprice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomprice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomprice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomprice: %w", err)
	}
	return oldValue.Roomprice, nil
}

// ResetRoomprice reset all changes of the "roomprice" field.
func (m *RoomdetailMutation) ResetRoomprice() {
	m.roomprice = nil
}

// SetEquipmentsID sets the equipments edge to Equipment by id.
func (m *RoomdetailMutation) SetEquipmentsID(id int) {
	m.equipments = &id
}

// ClearEquipments clears the equipments edge to Equipment.
func (m *RoomdetailMutation) ClearEquipments() {
	m.clearedequipments = true
}

// EquipmentsCleared returns if the edge equipments was cleared.
func (m *RoomdetailMutation) EquipmentsCleared() bool {
	return m.clearedequipments
}

// EquipmentsID returns the equipments id in the mutation.
func (m *RoomdetailMutation) EquipmentsID() (id int, exists bool) {
	if m.equipments != nil {
		return *m.equipments, true
	}
	return
}

// EquipmentsIDs returns the equipments ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentsID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) EquipmentsIDs() (ids []int) {
	if id := m.equipments; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipments reset all changes of the "equipments" edge.
func (m *RoomdetailMutation) ResetEquipments() {
	m.equipments = nil
	m.clearedequipments = false
}

// SetFacilitiesID sets the facilities edge to Facilitie by id.
func (m *RoomdetailMutation) SetFacilitiesID(id int) {
	m.facilities = &id
}

// ClearFacilities clears the facilities edge to Facilitie.
func (m *RoomdetailMutation) ClearFacilities() {
	m.clearedfacilities = true
}

// FacilitiesCleared returns if the edge facilities was cleared.
func (m *RoomdetailMutation) FacilitiesCleared() bool {
	return m.clearedfacilities
}

// FacilitiesID returns the facilities id in the mutation.
func (m *RoomdetailMutation) FacilitiesID() (id int, exists bool) {
	if m.facilities != nil {
		return *m.facilities, true
	}
	return
}

// FacilitiesIDs returns the facilities ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FacilitiesID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) FacilitiesIDs() (ids []int) {
	if id := m.facilities; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFacilities reset all changes of the "facilities" edge.
func (m *RoomdetailMutation) ResetFacilities() {
	m.facilities = nil
	m.clearedfacilities = false
}

// SetNearbyplacesID sets the nearbyplaces edge to Nearbyplace by id.
func (m *RoomdetailMutation) SetNearbyplacesID(id int) {
	m.nearbyplaces = &id
}

// ClearNearbyplaces clears the nearbyplaces edge to Nearbyplace.
func (m *RoomdetailMutation) ClearNearbyplaces() {
	m.clearednearbyplaces = true
}

// NearbyplacesCleared returns if the edge nearbyplaces was cleared.
func (m *RoomdetailMutation) NearbyplacesCleared() bool {
	return m.clearednearbyplaces
}

// NearbyplacesID returns the nearbyplaces id in the mutation.
func (m *RoomdetailMutation) NearbyplacesID() (id int, exists bool) {
	if m.nearbyplaces != nil {
		return *m.nearbyplaces, true
	}
	return
}

// NearbyplacesIDs returns the nearbyplaces ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NearbyplacesID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) NearbyplacesIDs() (ids []int) {
	if id := m.nearbyplaces; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNearbyplaces reset all changes of the "nearbyplaces" edge.
func (m *RoomdetailMutation) ResetNearbyplaces() {
	m.nearbyplaces = nil
	m.clearednearbyplaces = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *RoomdetailMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *RoomdetailMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *RoomdetailMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *RoomdetailMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *RoomdetailMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetQuantityID sets the quantity edge to Quantity by id.
func (m *RoomdetailMutation) SetQuantityID(id int) {
	m.quantity = &id
}

// ClearQuantity clears the quantity edge to Quantity.
func (m *RoomdetailMutation) ClearQuantity() {
	m.clearedquantity = true
}

// QuantityCleared returns if the edge quantity was cleared.
func (m *RoomdetailMutation) QuantityCleared() bool {
	return m.clearedquantity
}

// QuantityID returns the quantity id in the mutation.
func (m *RoomdetailMutation) QuantityID() (id int, exists bool) {
	if m.quantity != nil {
		return *m.quantity, true
	}
	return
}

// QuantityIDs returns the quantity ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// QuantityID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) QuantityIDs() (ids []int) {
	if id := m.quantity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuantity reset all changes of the "quantity" edge.
func (m *RoomdetailMutation) ResetQuantity() {
	m.quantity = nil
	m.clearedquantity = false
}

// SetStaytypeID sets the staytype edge to Staytype by id.
func (m *RoomdetailMutation) SetStaytypeID(id int) {
	m.staytype = &id
}

// ClearStaytype clears the staytype edge to Staytype.
func (m *RoomdetailMutation) ClearStaytype() {
	m.clearedstaytype = true
}

// StaytypeCleared returns if the edge staytype was cleared.
func (m *RoomdetailMutation) StaytypeCleared() bool {
	return m.clearedstaytype
}

// StaytypeID returns the staytype id in the mutation.
func (m *RoomdetailMutation) StaytypeID() (id int, exists bool) {
	if m.staytype != nil {
		return *m.staytype, true
	}
	return
}

// StaytypeIDs returns the staytype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StaytypeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) StaytypeIDs() (ids []int) {
	if id := m.staytype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaytype reset all changes of the "staytype" edge.
func (m *RoomdetailMutation) ResetStaytype() {
	m.staytype = nil
	m.clearedstaytype = false
}

// SetRoomdetailsID sets the roomdetails edge to Lease by id.
func (m *RoomdetailMutation) SetRoomdetailsID(id int) {
	m.roomdetails = &id
}

// ClearRoomdetails clears the roomdetails edge to Lease.
func (m *RoomdetailMutation) ClearRoomdetails() {
	m.clearedroomdetails = true
}

// RoomdetailsCleared returns if the edge roomdetails was cleared.
func (m *RoomdetailMutation) RoomdetailsCleared() bool {
	return m.clearedroomdetails
}

// RoomdetailsID returns the roomdetails id in the mutation.
func (m *RoomdetailMutation) RoomdetailsID() (id int, exists bool) {
	if m.roomdetails != nil {
		return *m.roomdetails, true
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomdetailsID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) RoomdetailsIDs() (ids []int) {
	if id := m.roomdetails; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *RoomdetailMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.clearedroomdetails = false
}

// Op returns the operation name.
func (m *RoomdetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Roomdetail).
func (m *RoomdetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomdetailMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.roomtypename != nil {
		fields = append(fields, roomdetail.FieldRoomtypename)
	}
	if m.roomprice != nil {
		fields = append(fields, roomdetail.FieldRoomprice)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomdetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomdetail.FieldRoomtypename:
		return m.Roomtypename()
	case roomdetail.FieldRoomprice:
		return m.Roomprice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomdetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomdetail.FieldRoomtypename:
		return m.OldRoomtypename(ctx)
	case roomdetail.FieldRoomprice:
		return m.OldRoomprice(ctx)
	}
	return nil, fmt.Errorf("unknown Roomdetail field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomdetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomdetail.FieldRoomtypename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomtypename(v)
		return nil
	case roomdetail.FieldRoomprice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomprice(v)
		return nil
	}
	return fmt.Errorf("unknown Roomdetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomdetailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomdetailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomdetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Roomdetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomdetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomdetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomdetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Roomdetail nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomdetailMutation) ResetField(name string) error {
	switch name {
	case roomdetail.FieldRoomtypename:
		m.ResetRoomtypename()
		return nil
	case roomdetail.FieldRoomprice:
		m.ResetRoomprice()
		return nil
	}
	return fmt.Errorf("unknown Roomdetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomdetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.equipments != nil {
		edges = append(edges, roomdetail.EdgeEquipments)
	}
	if m.facilities != nil {
		edges = append(edges, roomdetail.EdgeFacilities)
	}
	if m.nearbyplaces != nil {
		edges = append(edges, roomdetail.EdgeNearbyplaces)
	}
	if m.employee != nil {
		edges = append(edges, roomdetail.EdgeEmployee)
	}
	if m.quantity != nil {
		edges = append(edges, roomdetail.EdgeQuantity)
	}
	if m.staytype != nil {
		edges = append(edges, roomdetail.EdgeStaytype)
	}
	if m.roomdetails != nil {
		edges = append(edges, roomdetail.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomdetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roomdetail.EdgeEquipments:
		if id := m.equipments; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeFacilities:
		if id := m.facilities; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeNearbyplaces:
		if id := m.nearbyplaces; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeQuantity:
		if id := m.quantity; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeStaytype:
		if id := m.staytype; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeRoomdetails:
		if id := m.roomdetails; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomdetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomdetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomdetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedequipments {
		edges = append(edges, roomdetail.EdgeEquipments)
	}
	if m.clearedfacilities {
		edges = append(edges, roomdetail.EdgeFacilities)
	}
	if m.clearednearbyplaces {
		edges = append(edges, roomdetail.EdgeNearbyplaces)
	}
	if m.clearedemployee {
		edges = append(edges, roomdetail.EdgeEmployee)
	}
	if m.clearedquantity {
		edges = append(edges, roomdetail.EdgeQuantity)
	}
	if m.clearedstaytype {
		edges = append(edges, roomdetail.EdgeStaytype)
	}
	if m.clearedroomdetails {
		edges = append(edges, roomdetail.EdgeRoomdetails)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomdetailMutation) EdgeCleared(name string) bool {
	switch name {
	case roomdetail.EdgeEquipments:
		return m.clearedequipments
	case roomdetail.EdgeFacilities:
		return m.clearedfacilities
	case roomdetail.EdgeNearbyplaces:
		return m.clearednearbyplaces
	case roomdetail.EdgeEmployee:
		return m.clearedemployee
	case roomdetail.EdgeQuantity:
		return m.clearedquantity
	case roomdetail.EdgeStaytype:
		return m.clearedstaytype
	case roomdetail.EdgeRoomdetails:
		return m.clearedroomdetails
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomdetailMutation) ClearEdge(name string) error {
	switch name {
	case roomdetail.EdgeEquipments:
		m.ClearEquipments()
		return nil
	case roomdetail.EdgeFacilities:
		m.ClearFacilities()
		return nil
	case roomdetail.EdgeNearbyplaces:
		m.ClearNearbyplaces()
		return nil
	case roomdetail.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case roomdetail.EdgeQuantity:
		m.ClearQuantity()
		return nil
	case roomdetail.EdgeStaytype:
		m.ClearStaytype()
		return nil
	case roomdetail.EdgeRoomdetails:
		m.ClearRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Roomdetail unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomdetailMutation) ResetEdge(name string) error {
	switch name {
	case roomdetail.EdgeEquipments:
		m.ResetEquipments()
		return nil
	case roomdetail.EdgeFacilities:
		m.ResetFacilities()
		return nil
	case roomdetail.EdgeNearbyplaces:
		m.ResetNearbyplaces()
		return nil
	case roomdetail.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case roomdetail.EdgeQuantity:
		m.ResetQuantity()
		return nil
	case roomdetail.EdgeStaytype:
		m.ResetStaytype()
		return nil
	case roomdetail.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Roomdetail edge %s", name)
}

// StatusdMutation represents an operation that mutate the Statusds
// nodes in the graph.
type StatusdMutation struct {
	config
	op              Op
	typ             string
	id              *int
	statusdname     *string
	clearedFields   map[string]struct{}
	statusds        map[int]struct{}
	removedstatusds map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Statusd, error)
}

var _ ent.Mutation = (*StatusdMutation)(nil)

// statusdOption allows to manage the mutation configuration using functional options.
type statusdOption func(*StatusdMutation)

// newStatusdMutation creates new mutation for $n.Name.
func newStatusdMutation(c config, op Op, opts ...statusdOption) *StatusdMutation {
	m := &StatusdMutation{
		config:        c,
		op:            op,
		typ:           TypeStatusd,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusdID sets the id field of the mutation.
func withStatusdID(id int) statusdOption {
	return func(m *StatusdMutation) {
		var (
			err   error
			once  sync.Once
			value *Statusd
		)
		m.oldValue = func(ctx context.Context) (*Statusd, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statusd.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatusd sets the old Statusd of the mutation.
func withStatusd(node *Statusd) statusdOption {
	return func(m *StatusdMutation) {
		m.oldValue = func(context.Context) (*Statusd, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusdMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusdMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatusdMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatusdname sets the statusdname field.
func (m *StatusdMutation) SetStatusdname(s string) {
	m.statusdname = &s
}

// Statusdname returns the statusdname value in the mutation.
func (m *StatusdMutation) Statusdname() (r string, exists bool) {
	v := m.statusdname
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusdname returns the old statusdname value of the Statusd.
// If the Statusd object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusdMutation) OldStatusdname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusdname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusdname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusdname: %w", err)
	}
	return oldValue.Statusdname, nil
}

// ResetStatusdname reset all changes of the "statusdname" field.
func (m *StatusdMutation) ResetStatusdname() {
	m.statusdname = nil
}

// AddStatusdIDs adds the statusds edge to Deposit by ids.
func (m *StatusdMutation) AddStatusdIDs(ids ...int) {
	if m.statusds == nil {
		m.statusds = make(map[int]struct{})
	}
	for i := range ids {
		m.statusds[ids[i]] = struct{}{}
	}
}

// RemoveStatusdIDs removes the statusds edge to Deposit by ids.
func (m *StatusdMutation) RemoveStatusdIDs(ids ...int) {
	if m.removedstatusds == nil {
		m.removedstatusds = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatusds[ids[i]] = struct{}{}
	}
}

// RemovedStatusds returns the removed ids of statusds.
func (m *StatusdMutation) RemovedStatusdsIDs() (ids []int) {
	for id := range m.removedstatusds {
		ids = append(ids, id)
	}
	return
}

// StatusdsIDs returns the statusds ids in the mutation.
func (m *StatusdMutation) StatusdsIDs() (ids []int) {
	for id := range m.statusds {
		ids = append(ids, id)
	}
	return
}

// ResetStatusds reset all changes of the "statusds" edge.
func (m *StatusdMutation) ResetStatusds() {
	m.statusds = nil
	m.removedstatusds = nil
}

// Op returns the operation name.
func (m *StatusdMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statusd).
func (m *StatusdMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatusdMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.statusdname != nil {
		fields = append(fields, statusd.FieldStatusdname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatusdMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statusd.FieldStatusdname:
		return m.Statusdname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatusdMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statusd.FieldStatusdname:
		return m.OldStatusdname(ctx)
	}
	return nil, fmt.Errorf("unknown Statusd field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusdMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statusd.FieldStatusdname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusdname(v)
		return nil
	}
	return fmt.Errorf("unknown Statusd field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatusdMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatusdMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusdMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statusd numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatusdMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatusdMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusdMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statusd nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatusdMutation) ResetField(name string) error {
	switch name {
	case statusd.FieldStatusdname:
		m.ResetStatusdname()
		return nil
	}
	return fmt.Errorf("unknown Statusd field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatusdMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.statusds != nil {
		edges = append(edges, statusd.EdgeStatusds)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatusdMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statusd.EdgeStatusds:
		ids := make([]ent.Value, 0, len(m.statusds))
		for id := range m.statusds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatusdMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatusds != nil {
		edges = append(edges, statusd.EdgeStatusds)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatusdMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statusd.EdgeStatusds:
		ids := make([]ent.Value, 0, len(m.removedstatusds))
		for id := range m.removedstatusds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatusdMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatusdMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatusdMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statusd unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatusdMutation) ResetEdge(name string) error {
	switch name {
	case statusd.EdgeStatusds:
		m.ResetStatusds()
		return nil
	}
	return fmt.Errorf("unknown Statusd edge %s", name)
}

// StaytypeMutation represents an operation that mutate the Staytypes
// nodes in the graph.
type StaytypeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	staytype           *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Staytype, error)
}

var _ ent.Mutation = (*StaytypeMutation)(nil)

// staytypeOption allows to manage the mutation configuration using functional options.
type staytypeOption func(*StaytypeMutation)

// newStaytypeMutation creates new mutation for $n.Name.
func newStaytypeMutation(c config, op Op, opts ...staytypeOption) *StaytypeMutation {
	m := &StaytypeMutation{
		config:        c,
		op:            op,
		typ:           TypeStaytype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaytypeID sets the id field of the mutation.
func withStaytypeID(id int) staytypeOption {
	return func(m *StaytypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Staytype
		)
		m.oldValue = func(ctx context.Context) (*Staytype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staytype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaytype sets the old Staytype of the mutation.
func withStaytype(node *Staytype) staytypeOption {
	return func(m *StaytypeMutation) {
		m.oldValue = func(context.Context) (*Staytype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaytypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaytypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StaytypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStaytype sets the staytype field.
func (m *StaytypeMutation) SetStaytype(s string) {
	m.staytype = &s
}

// Staytype returns the staytype value in the mutation.
func (m *StaytypeMutation) Staytype() (r string, exists bool) {
	v := m.staytype
	if v == nil {
		return
	}
	return *v, true
}

// OldStaytype returns the old staytype value of the Staytype.
// If the Staytype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StaytypeMutation) OldStaytype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStaytype is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStaytype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaytype: %w", err)
	}
	return oldValue.Staytype, nil
}

// ResetStaytype reset all changes of the "staytype" field.
func (m *StaytypeMutation) ResetStaytype() {
	m.staytype = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *StaytypeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *StaytypeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *StaytypeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *StaytypeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *StaytypeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *StaytypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Staytype).
func (m *StaytypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StaytypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.staytype != nil {
		fields = append(fields, staytype.FieldStaytype)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StaytypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staytype.FieldStaytype:
		return m.Staytype()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StaytypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staytype.FieldStaytype:
		return m.OldStaytype(ctx)
	}
	return nil, fmt.Errorf("unknown Staytype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StaytypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staytype.FieldStaytype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaytype(v)
		return nil
	}
	return fmt.Errorf("unknown Staytype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StaytypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StaytypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StaytypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Staytype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StaytypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StaytypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaytypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Staytype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StaytypeMutation) ResetField(name string) error {
	switch name {
	case staytype.FieldStaytype:
		m.ResetStaytype()
		return nil
	}
	return fmt.Errorf("unknown Staytype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StaytypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, staytype.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StaytypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staytype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StaytypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, staytype.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StaytypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case staytype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StaytypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StaytypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StaytypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Staytype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StaytypeMutation) ResetEdge(name string) error {
	switch name {
	case staytype.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Staytype edge %s", name)
}

// WifiMutation represents an operation that mutate the Wifis
// nodes in the graph.
type WifiMutation struct {
	config
	op            Op
	typ           string
	id            *int
	wifiname      *string
	clearedFields map[string]struct{}
	wifis         map[int]struct{}
	removedwifis  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Wifi, error)
}

var _ ent.Mutation = (*WifiMutation)(nil)

// wifiOption allows to manage the mutation configuration using functional options.
type wifiOption func(*WifiMutation)

// newWifiMutation creates new mutation for $n.Name.
func newWifiMutation(c config, op Op, opts ...wifiOption) *WifiMutation {
	m := &WifiMutation{
		config:        c,
		op:            op,
		typ:           TypeWifi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWifiID sets the id field of the mutation.
func withWifiID(id int) wifiOption {
	return func(m *WifiMutation) {
		var (
			err   error
			once  sync.Once
			value *Wifi
		)
		m.oldValue = func(ctx context.Context) (*Wifi, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wifi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWifi sets the old Wifi of the mutation.
func withWifi(node *Wifi) wifiOption {
	return func(m *WifiMutation) {
		m.oldValue = func(context.Context) (*Wifi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WifiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WifiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WifiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWifiname sets the wifiname field.
func (m *WifiMutation) SetWifiname(s string) {
	m.wifiname = &s
}

// Wifiname returns the wifiname value in the mutation.
func (m *WifiMutation) Wifiname() (r string, exists bool) {
	v := m.wifiname
	if v == nil {
		return
	}
	return *v, true
}

// OldWifiname returns the old wifiname value of the Wifi.
// If the Wifi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WifiMutation) OldWifiname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWifiname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWifiname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWifiname: %w", err)
	}
	return oldValue.Wifiname, nil
}

// ResetWifiname reset all changes of the "wifiname" field.
func (m *WifiMutation) ResetWifiname() {
	m.wifiname = nil
}

// AddWifiIDs adds the wifis edge to Lease by ids.
func (m *WifiMutation) AddWifiIDs(ids ...int) {
	if m.wifis == nil {
		m.wifis = make(map[int]struct{})
	}
	for i := range ids {
		m.wifis[ids[i]] = struct{}{}
	}
}

// RemoveWifiIDs removes the wifis edge to Lease by ids.
func (m *WifiMutation) RemoveWifiIDs(ids ...int) {
	if m.removedwifis == nil {
		m.removedwifis = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwifis[ids[i]] = struct{}{}
	}
}

// RemovedWifis returns the removed ids of wifis.
func (m *WifiMutation) RemovedWifisIDs() (ids []int) {
	for id := range m.removedwifis {
		ids = append(ids, id)
	}
	return
}

// WifisIDs returns the wifis ids in the mutation.
func (m *WifiMutation) WifisIDs() (ids []int) {
	for id := range m.wifis {
		ids = append(ids, id)
	}
	return
}

// ResetWifis reset all changes of the "wifis" edge.
func (m *WifiMutation) ResetWifis() {
	m.wifis = nil
	m.removedwifis = nil
}

// Op returns the operation name.
func (m *WifiMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Wifi).
func (m *WifiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WifiMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.wifiname != nil {
		fields = append(fields, wifi.FieldWifiname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WifiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wifi.FieldWifiname:
		return m.Wifiname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WifiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wifi.FieldWifiname:
		return m.OldWifiname(ctx)
	}
	return nil, fmt.Errorf("unknown Wifi field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WifiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wifi.FieldWifiname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWifiname(v)
		return nil
	}
	return fmt.Errorf("unknown Wifi field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WifiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WifiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WifiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Wifi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WifiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WifiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WifiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wifi nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WifiMutation) ResetField(name string) error {
	switch name {
	case wifi.FieldWifiname:
		m.ResetWifiname()
		return nil
	}
	return fmt.Errorf("unknown Wifi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WifiMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.wifis != nil {
		edges = append(edges, wifi.EdgeWifis)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WifiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wifi.EdgeWifis:
		ids := make([]ent.Value, 0, len(m.wifis))
		for id := range m.wifis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WifiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedwifis != nil {
		edges = append(edges, wifi.EdgeWifis)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WifiMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wifi.EdgeWifis:
		ids := make([]ent.Value, 0, len(m.removedwifis))
		for id := range m.removedwifis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WifiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WifiMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WifiMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Wifi unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WifiMutation) ResetEdge(name string) error {
	switch name {
	case wifi.EdgeWifis:
		m.ResetWifis()
		return nil
	}
	return fmt.Errorf("unknown Wifi edge %s", name)
}
