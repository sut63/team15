// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team15/app/ent/bedtype"
	"github.com/team15/app/ent/bill"
	"github.com/team15/app/ent/cleanername"
	"github.com/team15/app/ent/cleaningroom"
	"github.com/team15/app/ent/deposit"
	"github.com/team15/app/ent/employee"
	"github.com/team15/app/ent/jobposition"
	"github.com/team15/app/ent/lease"
	"github.com/team15/app/ent/lengthtime"
	"github.com/team15/app/ent/payment"
	"github.com/team15/app/ent/petrule"
	"github.com/team15/app/ent/pledge"
	"github.com/team15/app/ent/rentalstatus"
	"github.com/team15/app/ent/repairinvoice"
	"github.com/team15/app/ent/roomdetail"
	"github.com/team15/app/ent/situation"
	"github.com/team15/app/ent/statusd"
	"github.com/team15/app/ent/staytype"
	"github.com/team15/app/ent/wifi"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBedtype       = "Bedtype"
	TypeBill          = "Bill"
	TypeCleanername   = "Cleanername"
	TypeCleaningroom  = "Cleaningroom"
	TypeDeposit       = "Deposit"
	TypeEmployee      = "Employee"
	TypeJobposition   = "Jobposition"
	TypeLease         = "Lease"
	TypeLengthtime    = "Lengthtime"
	TypePayment       = "Payment"
	TypePetrule       = "Petrule"
	TypePledge        = "Pledge"
	TypeRentalstatus  = "Rentalstatus"
	TypeRepairinvoice = "Repairinvoice"
	TypeRoomdetail    = "Roomdetail"
	TypeSituation     = "Situation"
	TypeStatusd       = "Statusd"
	TypeStaytype      = "Staytype"
	TypeWifi          = "Wifi"
)

// BedtypeMutation represents an operation that mutate the Bedtypes
// nodes in the graph.
type BedtypeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	bedtypename        *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Bedtype, error)
}

var _ ent.Mutation = (*BedtypeMutation)(nil)

// bedtypeOption allows to manage the mutation configuration using functional options.
type bedtypeOption func(*BedtypeMutation)

// newBedtypeMutation creates new mutation for $n.Name.
func newBedtypeMutation(c config, op Op, opts ...bedtypeOption) *BedtypeMutation {
	m := &BedtypeMutation{
		config:        c,
		op:            op,
		typ:           TypeBedtype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBedtypeID sets the id field of the mutation.
func withBedtypeID(id int) bedtypeOption {
	return func(m *BedtypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Bedtype
		)
		m.oldValue = func(ctx context.Context) (*Bedtype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bedtype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBedtype sets the old Bedtype of the mutation.
func withBedtype(node *Bedtype) bedtypeOption {
	return func(m *BedtypeMutation) {
		m.oldValue = func(context.Context) (*Bedtype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BedtypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BedtypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BedtypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBedtypename sets the bedtypename field.
func (m *BedtypeMutation) SetBedtypename(s string) {
	m.bedtypename = &s
}

// Bedtypename returns the bedtypename value in the mutation.
func (m *BedtypeMutation) Bedtypename() (r string, exists bool) {
	v := m.bedtypename
	if v == nil {
		return
	}
	return *v, true
}

// OldBedtypename returns the old bedtypename value of the Bedtype.
// If the Bedtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BedtypeMutation) OldBedtypename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBedtypename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBedtypename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBedtypename: %w", err)
	}
	return oldValue.Bedtypename, nil
}

// ResetBedtypename reset all changes of the "bedtypename" field.
func (m *BedtypeMutation) ResetBedtypename() {
	m.bedtypename = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *BedtypeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *BedtypeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *BedtypeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *BedtypeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *BedtypeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *BedtypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bedtype).
func (m *BedtypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BedtypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.bedtypename != nil {
		fields = append(fields, bedtype.FieldBedtypename)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BedtypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bedtype.FieldBedtypename:
		return m.Bedtypename()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BedtypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bedtype.FieldBedtypename:
		return m.OldBedtypename(ctx)
	}
	return nil, fmt.Errorf("unknown Bedtype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BedtypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bedtype.FieldBedtypename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBedtypename(v)
		return nil
	}
	return fmt.Errorf("unknown Bedtype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BedtypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BedtypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BedtypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bedtype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BedtypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BedtypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BedtypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bedtype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BedtypeMutation) ResetField(name string) error {
	switch name {
	case bedtype.FieldBedtypename:
		m.ResetBedtypename()
		return nil
	}
	return fmt.Errorf("unknown Bedtype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BedtypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, bedtype.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BedtypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bedtype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BedtypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, bedtype.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BedtypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bedtype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BedtypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BedtypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BedtypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bedtype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BedtypeMutation) ResetEdge(name string) error {
	switch name {
	case bedtype.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Bedtype edge %s", name)
}

// BillMutation represents an operation that mutate the Bills
// nodes in the graph.
type BillMutation struct {
	config
	op                Op
	typ               string
	id                *int
	addedtime         *time.Time
	tell              *string
	taxpayer          *string
	total             *string
	clearedFields     map[string]struct{}
	_Situation        *int
	cleared_Situation bool
	_Payment          *int
	cleared_Payment   bool
	_Lease            *int
	cleared_Lease     bool
	done              bool
	oldValue          func(context.Context) (*Bill, error)
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows to manage the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for $n.Name.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the id field of the mutation.
func withBillID(id int) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *BillMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *BillMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *BillMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetTell sets the tell field.
func (m *BillMutation) SetTell(s string) {
	m.tell = &s
}

// Tell returns the tell value in the mutation.
func (m *BillMutation) Tell() (r string, exists bool) {
	v := m.tell
	if v == nil {
		return
	}
	return *v, true
}

// OldTell returns the old tell value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldTell(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTell is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTell: %w", err)
	}
	return oldValue.Tell, nil
}

// ResetTell reset all changes of the "tell" field.
func (m *BillMutation) ResetTell() {
	m.tell = nil
}

// SetTaxpayer sets the taxpayer field.
func (m *BillMutation) SetTaxpayer(s string) {
	m.taxpayer = &s
}

// Taxpayer returns the taxpayer value in the mutation.
func (m *BillMutation) Taxpayer() (r string, exists bool) {
	v := m.taxpayer
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxpayer returns the old taxpayer value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldTaxpayer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxpayer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxpayer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxpayer: %w", err)
	}
	return oldValue.Taxpayer, nil
}

// ResetTaxpayer reset all changes of the "taxpayer" field.
func (m *BillMutation) ResetTaxpayer() {
	m.taxpayer = nil
}

// SetTotal sets the total field.
func (m *BillMutation) SetTotal(s string) {
	m.total = &s
}

// Total returns the total value in the mutation.
func (m *BillMutation) Total() (r string, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old total value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldTotal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// ResetTotal reset all changes of the "total" field.
func (m *BillMutation) ResetTotal() {
	m.total = nil
}

// SetSituationID sets the Situation edge to Situation by id.
func (m *BillMutation) SetSituationID(id int) {
	m._Situation = &id
}

// ClearSituation clears the Situation edge to Situation.
func (m *BillMutation) ClearSituation() {
	m.cleared_Situation = true
}

// SituationCleared returns if the edge Situation was cleared.
func (m *BillMutation) SituationCleared() bool {
	return m.cleared_Situation
}

// SituationID returns the Situation id in the mutation.
func (m *BillMutation) SituationID() (id int, exists bool) {
	if m._Situation != nil {
		return *m._Situation, true
	}
	return
}

// SituationIDs returns the Situation ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SituationID instead. It exists only for internal usage by the builders.
func (m *BillMutation) SituationIDs() (ids []int) {
	if id := m._Situation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSituation reset all changes of the "Situation" edge.
func (m *BillMutation) ResetSituation() {
	m._Situation = nil
	m.cleared_Situation = false
}

// SetPaymentID sets the Payment edge to Payment by id.
func (m *BillMutation) SetPaymentID(id int) {
	m._Payment = &id
}

// ClearPayment clears the Payment edge to Payment.
func (m *BillMutation) ClearPayment() {
	m.cleared_Payment = true
}

// PaymentCleared returns if the edge Payment was cleared.
func (m *BillMutation) PaymentCleared() bool {
	return m.cleared_Payment
}

// PaymentID returns the Payment id in the mutation.
func (m *BillMutation) PaymentID() (id int, exists bool) {
	if m._Payment != nil {
		return *m._Payment, true
	}
	return
}

// PaymentIDs returns the Payment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PaymentID instead. It exists only for internal usage by the builders.
func (m *BillMutation) PaymentIDs() (ids []int) {
	if id := m._Payment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayment reset all changes of the "Payment" edge.
func (m *BillMutation) ResetPayment() {
	m._Payment = nil
	m.cleared_Payment = false
}

// SetLeaseID sets the Lease edge to Lease by id.
func (m *BillMutation) SetLeaseID(id int) {
	m._Lease = &id
}

// ClearLease clears the Lease edge to Lease.
func (m *BillMutation) ClearLease() {
	m.cleared_Lease = true
}

// LeaseCleared returns if the edge Lease was cleared.
func (m *BillMutation) LeaseCleared() bool {
	return m.cleared_Lease
}

// LeaseID returns the Lease id in the mutation.
func (m *BillMutation) LeaseID() (id int, exists bool) {
	if m._Lease != nil {
		return *m._Lease, true
	}
	return
}

// LeaseIDs returns the Lease ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LeaseID instead. It exists only for internal usage by the builders.
func (m *BillMutation) LeaseIDs() (ids []int) {
	if id := m._Lease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLease reset all changes of the "Lease" edge.
func (m *BillMutation) ResetLease() {
	m._Lease = nil
	m.cleared_Lease = false
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.addedtime != nil {
		fields = append(fields, bill.FieldAddedtime)
	}
	if m.tell != nil {
		fields = append(fields, bill.FieldTell)
	}
	if m.taxpayer != nil {
		fields = append(fields, bill.FieldTaxpayer)
	}
	if m.total != nil {
		fields = append(fields, bill.FieldTotal)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldAddedtime:
		return m.Addedtime()
	case bill.FieldTell:
		return m.Tell()
	case bill.FieldTaxpayer:
		return m.Taxpayer()
	case bill.FieldTotal:
		return m.Total()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldAddedtime:
		return m.OldAddedtime(ctx)
	case bill.FieldTell:
		return m.OldTell(ctx)
	case bill.FieldTaxpayer:
		return m.OldTaxpayer(ctx)
	case bill.FieldTotal:
		return m.OldTotal(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	case bill.FieldTell:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTell(v)
		return nil
	case bill.FieldTaxpayer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxpayer(v)
		return nil
	case bill.FieldTotal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	case bill.FieldTell:
		m.ResetTell()
		return nil
	case bill.FieldTaxpayer:
		m.ResetTaxpayer()
		return nil
	case bill.FieldTotal:
		m.ResetTotal()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Situation != nil {
		edges = append(edges, bill.EdgeSituation)
	}
	if m._Payment != nil {
		edges = append(edges, bill.EdgePayment)
	}
	if m._Lease != nil {
		edges = append(edges, bill.EdgeLease)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgeSituation:
		if id := m._Situation; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgePayment:
		if id := m._Payment; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeLease:
		if id := m._Lease; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Situation {
		edges = append(edges, bill.EdgeSituation)
	}
	if m.cleared_Payment {
		edges = append(edges, bill.EdgePayment)
	}
	if m.cleared_Lease {
		edges = append(edges, bill.EdgeLease)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgeSituation:
		return m.cleared_Situation
	case bill.EdgePayment:
		return m.cleared_Payment
	case bill.EdgeLease:
		return m.cleared_Lease
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgeSituation:
		m.ClearSituation()
		return nil
	case bill.EdgePayment:
		m.ClearPayment()
		return nil
	case bill.EdgeLease:
		m.ClearLease()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgeSituation:
		m.ResetSituation()
		return nil
	case bill.EdgePayment:
		m.ResetPayment()
		return nil
	case bill.EdgeLease:
		m.ResetLease()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// CleanernameMutation represents an operation that mutate the Cleanernames
// nodes in the graph.
type CleanernameMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	cleanername          *string
	clearedFields        map[string]struct{}
	cleaningrooms        map[int]struct{}
	removedcleaningrooms map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Cleanername, error)
}

var _ ent.Mutation = (*CleanernameMutation)(nil)

// cleanernameOption allows to manage the mutation configuration using functional options.
type cleanernameOption func(*CleanernameMutation)

// newCleanernameMutation creates new mutation for $n.Name.
func newCleanernameMutation(c config, op Op, opts ...cleanernameOption) *CleanernameMutation {
	m := &CleanernameMutation{
		config:        c,
		op:            op,
		typ:           TypeCleanername,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCleanernameID sets the id field of the mutation.
func withCleanernameID(id int) cleanernameOption {
	return func(m *CleanernameMutation) {
		var (
			err   error
			once  sync.Once
			value *Cleanername
		)
		m.oldValue = func(ctx context.Context) (*Cleanername, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cleanername.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCleanername sets the old Cleanername of the mutation.
func withCleanername(node *Cleanername) cleanernameOption {
	return func(m *CleanernameMutation) {
		m.oldValue = func(context.Context) (*Cleanername, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CleanernameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CleanernameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CleanernameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCleanername sets the cleanername field.
func (m *CleanernameMutation) SetCleanername(s string) {
	m.cleanername = &s
}

// Cleanername returns the cleanername value in the mutation.
func (m *CleanernameMutation) Cleanername() (r string, exists bool) {
	v := m.cleanername
	if v == nil {
		return
	}
	return *v, true
}

// OldCleanername returns the old cleanername value of the Cleanername.
// If the Cleanername object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleanernameMutation) OldCleanername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCleanername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCleanername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCleanername: %w", err)
	}
	return oldValue.Cleanername, nil
}

// ResetCleanername reset all changes of the "cleanername" field.
func (m *CleanernameMutation) ResetCleanername() {
	m.cleanername = nil
}

// AddCleaningroomIDs adds the cleaningrooms edge to Cleaningroom by ids.
func (m *CleanernameMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to Cleaningroom by ids.
func (m *CleanernameMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *CleanernameMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *CleanernameMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *CleanernameMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *CleanernameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cleanername).
func (m *CleanernameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CleanernameMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.cleanername != nil {
		fields = append(fields, cleanername.FieldCleanername)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CleanernameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cleanername.FieldCleanername:
		return m.Cleanername()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CleanernameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cleanername.FieldCleanername:
		return m.OldCleanername(ctx)
	}
	return nil, fmt.Errorf("unknown Cleanername field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleanernameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cleanername.FieldCleanername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCleanername(v)
		return nil
	}
	return fmt.Errorf("unknown Cleanername field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CleanernameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CleanernameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleanernameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cleanername numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CleanernameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CleanernameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CleanernameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cleanername nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CleanernameMutation) ResetField(name string) error {
	switch name {
	case cleanername.FieldCleanername:
		m.ResetCleanername()
		return nil
	}
	return fmt.Errorf("unknown Cleanername field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CleanernameMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleaningrooms != nil {
		edges = append(edges, cleanername.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CleanernameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cleanername.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CleanernameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcleaningrooms != nil {
		edges = append(edges, cleanername.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CleanernameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cleanername.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CleanernameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CleanernameMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CleanernameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Cleanername unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CleanernameMutation) ResetEdge(name string) error {
	switch name {
	case cleanername.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown Cleanername edge %s", name)
}

// CleaningroomMutation represents an operation that mutate the Cleaningrooms
// nodes in the graph.
type CleaningroomMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	note                *string
	dateandstarttime    *time.Time
	phonenumber         *string
	numofem             *int
	addnumofem          *int
	clearedFields       map[string]struct{}
	roomdetail          *int
	clearedroomdetail   bool
	_Cleanername        *int
	cleared_Cleanername bool
	_Lengthtime         *int
	cleared_Lengthtime  bool
	_Employee           *int
	cleared_Employee    bool
	done                bool
	oldValue            func(context.Context) (*Cleaningroom, error)
}

var _ ent.Mutation = (*CleaningroomMutation)(nil)

// cleaningroomOption allows to manage the mutation configuration using functional options.
type cleaningroomOption func(*CleaningroomMutation)

// newCleaningroomMutation creates new mutation for $n.Name.
func newCleaningroomMutation(c config, op Op, opts ...cleaningroomOption) *CleaningroomMutation {
	m := &CleaningroomMutation{
		config:        c,
		op:            op,
		typ:           TypeCleaningroom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCleaningroomID sets the id field of the mutation.
func withCleaningroomID(id int) cleaningroomOption {
	return func(m *CleaningroomMutation) {
		var (
			err   error
			once  sync.Once
			value *Cleaningroom
		)
		m.oldValue = func(ctx context.Context) (*Cleaningroom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cleaningroom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCleaningroom sets the old Cleaningroom of the mutation.
func withCleaningroom(node *Cleaningroom) cleaningroomOption {
	return func(m *CleaningroomMutation) {
		m.oldValue = func(context.Context) (*Cleaningroom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CleaningroomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CleaningroomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CleaningroomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNote sets the note field.
func (m *CleaningroomMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the note value in the mutation.
func (m *CleaningroomMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old note value of the Cleaningroom.
// If the Cleaningroom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleaningroomMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote reset all changes of the "note" field.
func (m *CleaningroomMutation) ResetNote() {
	m.note = nil
}

// SetDateandstarttime sets the dateandstarttime field.
func (m *CleaningroomMutation) SetDateandstarttime(t time.Time) {
	m.dateandstarttime = &t
}

// Dateandstarttime returns the dateandstarttime value in the mutation.
func (m *CleaningroomMutation) Dateandstarttime() (r time.Time, exists bool) {
	v := m.dateandstarttime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateandstarttime returns the old dateandstarttime value of the Cleaningroom.
// If the Cleaningroom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleaningroomMutation) OldDateandstarttime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateandstarttime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateandstarttime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateandstarttime: %w", err)
	}
	return oldValue.Dateandstarttime, nil
}

// ResetDateandstarttime reset all changes of the "dateandstarttime" field.
func (m *CleaningroomMutation) ResetDateandstarttime() {
	m.dateandstarttime = nil
}

// SetPhonenumber sets the phonenumber field.
func (m *CleaningroomMutation) SetPhonenumber(s string) {
	m.phonenumber = &s
}

// Phonenumber returns the phonenumber value in the mutation.
func (m *CleaningroomMutation) Phonenumber() (r string, exists bool) {
	v := m.phonenumber
	if v == nil {
		return
	}
	return *v, true
}

// OldPhonenumber returns the old phonenumber value of the Cleaningroom.
// If the Cleaningroom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleaningroomMutation) OldPhonenumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhonenumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhonenumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhonenumber: %w", err)
	}
	return oldValue.Phonenumber, nil
}

// ResetPhonenumber reset all changes of the "phonenumber" field.
func (m *CleaningroomMutation) ResetPhonenumber() {
	m.phonenumber = nil
}

// SetNumofem sets the numofem field.
func (m *CleaningroomMutation) SetNumofem(i int) {
	m.numofem = &i
	m.addnumofem = nil
}

// Numofem returns the numofem value in the mutation.
func (m *CleaningroomMutation) Numofem() (r int, exists bool) {
	v := m.numofem
	if v == nil {
		return
	}
	return *v, true
}

// OldNumofem returns the old numofem value of the Cleaningroom.
// If the Cleaningroom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleaningroomMutation) OldNumofem(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumofem is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumofem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumofem: %w", err)
	}
	return oldValue.Numofem, nil
}

// AddNumofem adds i to numofem.
func (m *CleaningroomMutation) AddNumofem(i int) {
	if m.addnumofem != nil {
		*m.addnumofem += i
	} else {
		m.addnumofem = &i
	}
}

// AddedNumofem returns the value that was added to the numofem field in this mutation.
func (m *CleaningroomMutation) AddedNumofem() (r int, exists bool) {
	v := m.addnumofem
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumofem reset all changes of the "numofem" field.
func (m *CleaningroomMutation) ResetNumofem() {
	m.numofem = nil
	m.addnumofem = nil
}

// SetRoomdetailID sets the roomdetail edge to Roomdetail by id.
func (m *CleaningroomMutation) SetRoomdetailID(id int) {
	m.roomdetail = &id
}

// ClearRoomdetail clears the roomdetail edge to Roomdetail.
func (m *CleaningroomMutation) ClearRoomdetail() {
	m.clearedroomdetail = true
}

// RoomdetailCleared returns if the edge roomdetail was cleared.
func (m *CleaningroomMutation) RoomdetailCleared() bool {
	return m.clearedroomdetail
}

// RoomdetailID returns the roomdetail id in the mutation.
func (m *CleaningroomMutation) RoomdetailID() (id int, exists bool) {
	if m.roomdetail != nil {
		return *m.roomdetail, true
	}
	return
}

// RoomdetailIDs returns the roomdetail ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomdetailID instead. It exists only for internal usage by the builders.
func (m *CleaningroomMutation) RoomdetailIDs() (ids []int) {
	if id := m.roomdetail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomdetail reset all changes of the "roomdetail" edge.
func (m *CleaningroomMutation) ResetRoomdetail() {
	m.roomdetail = nil
	m.clearedroomdetail = false
}

// SetCleanernameID sets the Cleanername edge to Cleanername by id.
func (m *CleaningroomMutation) SetCleanernameID(id int) {
	m._Cleanername = &id
}

// ClearCleanername clears the Cleanername edge to Cleanername.
func (m *CleaningroomMutation) ClearCleanername() {
	m.cleared_Cleanername = true
}

// CleanernameCleared returns if the edge Cleanername was cleared.
func (m *CleaningroomMutation) CleanernameCleared() bool {
	return m.cleared_Cleanername
}

// CleanernameID returns the Cleanername id in the mutation.
func (m *CleaningroomMutation) CleanernameID() (id int, exists bool) {
	if m._Cleanername != nil {
		return *m._Cleanername, true
	}
	return
}

// CleanernameIDs returns the Cleanername ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CleanernameID instead. It exists only for internal usage by the builders.
func (m *CleaningroomMutation) CleanernameIDs() (ids []int) {
	if id := m._Cleanername; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCleanername reset all changes of the "Cleanername" edge.
func (m *CleaningroomMutation) ResetCleanername() {
	m._Cleanername = nil
	m.cleared_Cleanername = false
}

// SetLengthtimeID sets the Lengthtime edge to Lengthtime by id.
func (m *CleaningroomMutation) SetLengthtimeID(id int) {
	m._Lengthtime = &id
}

// ClearLengthtime clears the Lengthtime edge to Lengthtime.
func (m *CleaningroomMutation) ClearLengthtime() {
	m.cleared_Lengthtime = true
}

// LengthtimeCleared returns if the edge Lengthtime was cleared.
func (m *CleaningroomMutation) LengthtimeCleared() bool {
	return m.cleared_Lengthtime
}

// LengthtimeID returns the Lengthtime id in the mutation.
func (m *CleaningroomMutation) LengthtimeID() (id int, exists bool) {
	if m._Lengthtime != nil {
		return *m._Lengthtime, true
	}
	return
}

// LengthtimeIDs returns the Lengthtime ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LengthtimeID instead. It exists only for internal usage by the builders.
func (m *CleaningroomMutation) LengthtimeIDs() (ids []int) {
	if id := m._Lengthtime; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLengthtime reset all changes of the "Lengthtime" edge.
func (m *CleaningroomMutation) ResetLengthtime() {
	m._Lengthtime = nil
	m.cleared_Lengthtime = false
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *CleaningroomMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *CleaningroomMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *CleaningroomMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *CleaningroomMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *CleaningroomMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *CleaningroomMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// Op returns the operation name.
func (m *CleaningroomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cleaningroom).
func (m *CleaningroomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CleaningroomMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.note != nil {
		fields = append(fields, cleaningroom.FieldNote)
	}
	if m.dateandstarttime != nil {
		fields = append(fields, cleaningroom.FieldDateandstarttime)
	}
	if m.phonenumber != nil {
		fields = append(fields, cleaningroom.FieldPhonenumber)
	}
	if m.numofem != nil {
		fields = append(fields, cleaningroom.FieldNumofem)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CleaningroomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cleaningroom.FieldNote:
		return m.Note()
	case cleaningroom.FieldDateandstarttime:
		return m.Dateandstarttime()
	case cleaningroom.FieldPhonenumber:
		return m.Phonenumber()
	case cleaningroom.FieldNumofem:
		return m.Numofem()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CleaningroomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cleaningroom.FieldNote:
		return m.OldNote(ctx)
	case cleaningroom.FieldDateandstarttime:
		return m.OldDateandstarttime(ctx)
	case cleaningroom.FieldPhonenumber:
		return m.OldPhonenumber(ctx)
	case cleaningroom.FieldNumofem:
		return m.OldNumofem(ctx)
	}
	return nil, fmt.Errorf("unknown Cleaningroom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleaningroomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cleaningroom.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case cleaningroom.FieldDateandstarttime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateandstarttime(v)
		return nil
	case cleaningroom.FieldPhonenumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhonenumber(v)
		return nil
	case cleaningroom.FieldNumofem:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumofem(v)
		return nil
	}
	return fmt.Errorf("unknown Cleaningroom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CleaningroomMutation) AddedFields() []string {
	var fields []string
	if m.addnumofem != nil {
		fields = append(fields, cleaningroom.FieldNumofem)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CleaningroomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cleaningroom.FieldNumofem:
		return m.AddedNumofem()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleaningroomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cleaningroom.FieldNumofem:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumofem(v)
		return nil
	}
	return fmt.Errorf("unknown Cleaningroom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CleaningroomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CleaningroomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CleaningroomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cleaningroom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CleaningroomMutation) ResetField(name string) error {
	switch name {
	case cleaningroom.FieldNote:
		m.ResetNote()
		return nil
	case cleaningroom.FieldDateandstarttime:
		m.ResetDateandstarttime()
		return nil
	case cleaningroom.FieldPhonenumber:
		m.ResetPhonenumber()
		return nil
	case cleaningroom.FieldNumofem:
		m.ResetNumofem()
		return nil
	}
	return fmt.Errorf("unknown Cleaningroom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CleaningroomMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roomdetail != nil {
		edges = append(edges, cleaningroom.EdgeRoomdetail)
	}
	if m._Cleanername != nil {
		edges = append(edges, cleaningroom.EdgeCleanername)
	}
	if m._Lengthtime != nil {
		edges = append(edges, cleaningroom.EdgeLengthtime)
	}
	if m._Employee != nil {
		edges = append(edges, cleaningroom.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CleaningroomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cleaningroom.EdgeRoomdetail:
		if id := m.roomdetail; id != nil {
			return []ent.Value{*id}
		}
	case cleaningroom.EdgeCleanername:
		if id := m._Cleanername; id != nil {
			return []ent.Value{*id}
		}
	case cleaningroom.EdgeLengthtime:
		if id := m._Lengthtime; id != nil {
			return []ent.Value{*id}
		}
	case cleaningroom.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CleaningroomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CleaningroomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CleaningroomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroomdetail {
		edges = append(edges, cleaningroom.EdgeRoomdetail)
	}
	if m.cleared_Cleanername {
		edges = append(edges, cleaningroom.EdgeCleanername)
	}
	if m.cleared_Lengthtime {
		edges = append(edges, cleaningroom.EdgeLengthtime)
	}
	if m.cleared_Employee {
		edges = append(edges, cleaningroom.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CleaningroomMutation) EdgeCleared(name string) bool {
	switch name {
	case cleaningroom.EdgeRoomdetail:
		return m.clearedroomdetail
	case cleaningroom.EdgeCleanername:
		return m.cleared_Cleanername
	case cleaningroom.EdgeLengthtime:
		return m.cleared_Lengthtime
	case cleaningroom.EdgeEmployee:
		return m.cleared_Employee
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CleaningroomMutation) ClearEdge(name string) error {
	switch name {
	case cleaningroom.EdgeRoomdetail:
		m.ClearRoomdetail()
		return nil
	case cleaningroom.EdgeCleanername:
		m.ClearCleanername()
		return nil
	case cleaningroom.EdgeLengthtime:
		m.ClearLengthtime()
		return nil
	case cleaningroom.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Cleaningroom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CleaningroomMutation) ResetEdge(name string) error {
	switch name {
	case cleaningroom.EdgeRoomdetail:
		m.ResetRoomdetail()
		return nil
	case cleaningroom.EdgeCleanername:
		m.ResetCleanername()
		return nil
	case cleaningroom.EdgeLengthtime:
		m.ResetLengthtime()
		return nil
	case cleaningroom.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Cleaningroom edge %s", name)
}

// DepositMutation represents an operation that mutate the Deposits
// nodes in the graph.
type DepositMutation struct {
	config
	op               Op
	typ              string
	id               *int
	addedtime        *time.Time
	info             *string
	depositorname    *string
	depositortell    *string
	recipienttell    *string
	parcelcode       *string
	clearedFields    map[string]struct{}
	_Employee        *int
	cleared_Employee bool
	_Statusd         *int
	cleared_Statusd  bool
	_Lease           *int
	cleared_Lease    bool
	done             bool
	oldValue         func(context.Context) (*Deposit, error)
}

var _ ent.Mutation = (*DepositMutation)(nil)

// depositOption allows to manage the mutation configuration using functional options.
type depositOption func(*DepositMutation)

// newDepositMutation creates new mutation for $n.Name.
func newDepositMutation(c config, op Op, opts ...depositOption) *DepositMutation {
	m := &DepositMutation{
		config:        c,
		op:            op,
		typ:           TypeDeposit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepositID sets the id field of the mutation.
func withDepositID(id int) depositOption {
	return func(m *DepositMutation) {
		var (
			err   error
			once  sync.Once
			value *Deposit
		)
		m.oldValue = func(ctx context.Context) (*Deposit, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deposit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeposit sets the old Deposit of the mutation.
func withDeposit(node *Deposit) depositOption {
	return func(m *DepositMutation) {
		m.oldValue = func(context.Context) (*Deposit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepositMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepositMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepositMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *DepositMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *DepositMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *DepositMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetInfo sets the info field.
func (m *DepositMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the info value in the mutation.
func (m *DepositMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old info value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo reset all changes of the "info" field.
func (m *DepositMutation) ResetInfo() {
	m.info = nil
}

// SetDepositorname sets the depositorname field.
func (m *DepositMutation) SetDepositorname(s string) {
	m.depositorname = &s
}

// Depositorname returns the depositorname value in the mutation.
func (m *DepositMutation) Depositorname() (r string, exists bool) {
	v := m.depositorname
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositorname returns the old depositorname value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldDepositorname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepositorname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepositorname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositorname: %w", err)
	}
	return oldValue.Depositorname, nil
}

// ResetDepositorname reset all changes of the "depositorname" field.
func (m *DepositMutation) ResetDepositorname() {
	m.depositorname = nil
}

// SetDepositortell sets the depositortell field.
func (m *DepositMutation) SetDepositortell(s string) {
	m.depositortell = &s
}

// Depositortell returns the depositortell value in the mutation.
func (m *DepositMutation) Depositortell() (r string, exists bool) {
	v := m.depositortell
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositortell returns the old depositortell value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldDepositortell(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepositortell is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepositortell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositortell: %w", err)
	}
	return oldValue.Depositortell, nil
}

// ResetDepositortell reset all changes of the "depositortell" field.
func (m *DepositMutation) ResetDepositortell() {
	m.depositortell = nil
}

// SetRecipienttell sets the recipienttell field.
func (m *DepositMutation) SetRecipienttell(s string) {
	m.recipienttell = &s
}

// Recipienttell returns the recipienttell value in the mutation.
func (m *DepositMutation) Recipienttell() (r string, exists bool) {
	v := m.recipienttell
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipienttell returns the old recipienttell value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldRecipienttell(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecipienttell is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecipienttell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipienttell: %w", err)
	}
	return oldValue.Recipienttell, nil
}

// ResetRecipienttell reset all changes of the "recipienttell" field.
func (m *DepositMutation) ResetRecipienttell() {
	m.recipienttell = nil
}

// SetParcelcode sets the parcelcode field.
func (m *DepositMutation) SetParcelcode(s string) {
	m.parcelcode = &s
}

// Parcelcode returns the parcelcode value in the mutation.
func (m *DepositMutation) Parcelcode() (r string, exists bool) {
	v := m.parcelcode
	if v == nil {
		return
	}
	return *v, true
}

// OldParcelcode returns the old parcelcode value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldParcelcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParcelcode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParcelcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParcelcode: %w", err)
	}
	return oldValue.Parcelcode, nil
}

// ResetParcelcode reset all changes of the "parcelcode" field.
func (m *DepositMutation) ResetParcelcode() {
	m.parcelcode = nil
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *DepositMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *DepositMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *DepositMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *DepositMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *DepositMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *DepositMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// SetStatusdID sets the Statusd edge to Statusd by id.
func (m *DepositMutation) SetStatusdID(id int) {
	m._Statusd = &id
}

// ClearStatusd clears the Statusd edge to Statusd.
func (m *DepositMutation) ClearStatusd() {
	m.cleared_Statusd = true
}

// StatusdCleared returns if the edge Statusd was cleared.
func (m *DepositMutation) StatusdCleared() bool {
	return m.cleared_Statusd
}

// StatusdID returns the Statusd id in the mutation.
func (m *DepositMutation) StatusdID() (id int, exists bool) {
	if m._Statusd != nil {
		return *m._Statusd, true
	}
	return
}

// StatusdIDs returns the Statusd ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatusdID instead. It exists only for internal usage by the builders.
func (m *DepositMutation) StatusdIDs() (ids []int) {
	if id := m._Statusd; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusd reset all changes of the "Statusd" edge.
func (m *DepositMutation) ResetStatusd() {
	m._Statusd = nil
	m.cleared_Statusd = false
}

// SetLeaseID sets the Lease edge to Lease by id.
func (m *DepositMutation) SetLeaseID(id int) {
	m._Lease = &id
}

// ClearLease clears the Lease edge to Lease.
func (m *DepositMutation) ClearLease() {
	m.cleared_Lease = true
}

// LeaseCleared returns if the edge Lease was cleared.
func (m *DepositMutation) LeaseCleared() bool {
	return m.cleared_Lease
}

// LeaseID returns the Lease id in the mutation.
func (m *DepositMutation) LeaseID() (id int, exists bool) {
	if m._Lease != nil {
		return *m._Lease, true
	}
	return
}

// LeaseIDs returns the Lease ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LeaseID instead. It exists only for internal usage by the builders.
func (m *DepositMutation) LeaseIDs() (ids []int) {
	if id := m._Lease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLease reset all changes of the "Lease" edge.
func (m *DepositMutation) ResetLease() {
	m._Lease = nil
	m.cleared_Lease = false
}

// Op returns the operation name.
func (m *DepositMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Deposit).
func (m *DepositMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepositMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.addedtime != nil {
		fields = append(fields, deposit.FieldAddedtime)
	}
	if m.info != nil {
		fields = append(fields, deposit.FieldInfo)
	}
	if m.depositorname != nil {
		fields = append(fields, deposit.FieldDepositorname)
	}
	if m.depositortell != nil {
		fields = append(fields, deposit.FieldDepositortell)
	}
	if m.recipienttell != nil {
		fields = append(fields, deposit.FieldRecipienttell)
	}
	if m.parcelcode != nil {
		fields = append(fields, deposit.FieldParcelcode)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepositMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deposit.FieldAddedtime:
		return m.Addedtime()
	case deposit.FieldInfo:
		return m.Info()
	case deposit.FieldDepositorname:
		return m.Depositorname()
	case deposit.FieldDepositortell:
		return m.Depositortell()
	case deposit.FieldRecipienttell:
		return m.Recipienttell()
	case deposit.FieldParcelcode:
		return m.Parcelcode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepositMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deposit.FieldAddedtime:
		return m.OldAddedtime(ctx)
	case deposit.FieldInfo:
		return m.OldInfo(ctx)
	case deposit.FieldDepositorname:
		return m.OldDepositorname(ctx)
	case deposit.FieldDepositortell:
		return m.OldDepositortell(ctx)
	case deposit.FieldRecipienttell:
		return m.OldRecipienttell(ctx)
	case deposit.FieldParcelcode:
		return m.OldParcelcode(ctx)
	}
	return nil, fmt.Errorf("unknown Deposit field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepositMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deposit.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	case deposit.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case deposit.FieldDepositorname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositorname(v)
		return nil
	case deposit.FieldDepositortell:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositortell(v)
		return nil
	case deposit.FieldRecipienttell:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipienttell(v)
		return nil
	case deposit.FieldParcelcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParcelcode(v)
		return nil
	}
	return fmt.Errorf("unknown Deposit field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepositMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepositMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepositMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deposit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepositMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepositMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepositMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Deposit nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepositMutation) ResetField(name string) error {
	switch name {
	case deposit.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	case deposit.FieldInfo:
		m.ResetInfo()
		return nil
	case deposit.FieldDepositorname:
		m.ResetDepositorname()
		return nil
	case deposit.FieldDepositortell:
		m.ResetDepositortell()
		return nil
	case deposit.FieldRecipienttell:
		m.ResetRecipienttell()
		return nil
	case deposit.FieldParcelcode:
		m.ResetParcelcode()
		return nil
	}
	return fmt.Errorf("unknown Deposit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepositMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Employee != nil {
		edges = append(edges, deposit.EdgeEmployee)
	}
	if m._Statusd != nil {
		edges = append(edges, deposit.EdgeStatusd)
	}
	if m._Lease != nil {
		edges = append(edges, deposit.EdgeLease)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepositMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deposit.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	case deposit.EdgeStatusd:
		if id := m._Statusd; id != nil {
			return []ent.Value{*id}
		}
	case deposit.EdgeLease:
		if id := m._Lease; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepositMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepositMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepositMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Employee {
		edges = append(edges, deposit.EdgeEmployee)
	}
	if m.cleared_Statusd {
		edges = append(edges, deposit.EdgeStatusd)
	}
	if m.cleared_Lease {
		edges = append(edges, deposit.EdgeLease)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepositMutation) EdgeCleared(name string) bool {
	switch name {
	case deposit.EdgeEmployee:
		return m.cleared_Employee
	case deposit.EdgeStatusd:
		return m.cleared_Statusd
	case deposit.EdgeLease:
		return m.cleared_Lease
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepositMutation) ClearEdge(name string) error {
	switch name {
	case deposit.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case deposit.EdgeStatusd:
		m.ClearStatusd()
		return nil
	case deposit.EdgeLease:
		m.ClearLease()
		return nil
	}
	return fmt.Errorf("unknown Deposit unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepositMutation) ResetEdge(name string) error {
	switch name {
	case deposit.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case deposit.EdgeStatusd:
		m.ResetStatusd()
		return nil
	case deposit.EdgeLease:
		m.ResetLease()
		return nil
	}
	return fmt.Errorf("unknown Deposit edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	email                 *string
	password              *string
	clearedFields         map[string]struct{}
	employees             map[int]struct{}
	removedemployees      map[int]struct{}
	leasess               map[int]struct{}
	removedleasess        map[int]struct{}
	roomdetails           map[int]struct{}
	removedroomdetails    map[int]struct{}
	jobposition           *int
	clearedjobposition    bool
	repairinvoices        map[int]struct{}
	removedrepairinvoices map[int]struct{}
	cleaningrooms         map[int]struct{}
	removedcleaningrooms  map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *EmployeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EmployeeMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *EmployeeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *EmployeeMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *EmployeeMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *EmployeeMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *EmployeeMutation) ResetPassword() {
	m.password = nil
}

// AddEmployeeIDs adds the employees edge to Deposit by ids.
func (m *EmployeeMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Deposit by ids.
func (m *EmployeeMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *EmployeeMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *EmployeeMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *EmployeeMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// AddLeasesIDs adds the leasess edge to Lease by ids.
func (m *EmployeeMutation) AddLeasesIDs(ids ...int) {
	if m.leasess == nil {
		m.leasess = make(map[int]struct{})
	}
	for i := range ids {
		m.leasess[ids[i]] = struct{}{}
	}
}

// RemoveLeasesIDs removes the leasess edge to Lease by ids.
func (m *EmployeeMutation) RemoveLeasesIDs(ids ...int) {
	if m.removedleasess == nil {
		m.removedleasess = make(map[int]struct{})
	}
	for i := range ids {
		m.removedleasess[ids[i]] = struct{}{}
	}
}

// RemovedLeasess returns the removed ids of leasess.
func (m *EmployeeMutation) RemovedLeasessIDs() (ids []int) {
	for id := range m.removedleasess {
		ids = append(ids, id)
	}
	return
}

// LeasessIDs returns the leasess ids in the mutation.
func (m *EmployeeMutation) LeasessIDs() (ids []int) {
	for id := range m.leasess {
		ids = append(ids, id)
	}
	return
}

// ResetLeasess reset all changes of the "leasess" edge.
func (m *EmployeeMutation) ResetLeasess() {
	m.leasess = nil
	m.removedleasess = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *EmployeeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *EmployeeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *EmployeeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *EmployeeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *EmployeeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// SetJobpositionID sets the jobposition edge to Jobposition by id.
func (m *EmployeeMutation) SetJobpositionID(id int) {
	m.jobposition = &id
}

// ClearJobposition clears the jobposition edge to Jobposition.
func (m *EmployeeMutation) ClearJobposition() {
	m.clearedjobposition = true
}

// JobpositionCleared returns if the edge jobposition was cleared.
func (m *EmployeeMutation) JobpositionCleared() bool {
	return m.clearedjobposition
}

// JobpositionID returns the jobposition id in the mutation.
func (m *EmployeeMutation) JobpositionID() (id int, exists bool) {
	if m.jobposition != nil {
		return *m.jobposition, true
	}
	return
}

// JobpositionIDs returns the jobposition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// JobpositionID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) JobpositionIDs() (ids []int) {
	if id := m.jobposition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobposition reset all changes of the "jobposition" edge.
func (m *EmployeeMutation) ResetJobposition() {
	m.jobposition = nil
	m.clearedjobposition = false
}

// AddRepairinvoiceIDs adds the repairinvoices edge to Repairinvoice by ids.
func (m *EmployeeMutation) AddRepairinvoiceIDs(ids ...int) {
	if m.repairinvoices == nil {
		m.repairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.repairinvoices[ids[i]] = struct{}{}
	}
}

// RemoveRepairinvoiceIDs removes the repairinvoices edge to Repairinvoice by ids.
func (m *EmployeeMutation) RemoveRepairinvoiceIDs(ids ...int) {
	if m.removedrepairinvoices == nil {
		m.removedrepairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepairinvoices[ids[i]] = struct{}{}
	}
}

// RemovedRepairinvoices returns the removed ids of repairinvoices.
func (m *EmployeeMutation) RemovedRepairinvoicesIDs() (ids []int) {
	for id := range m.removedrepairinvoices {
		ids = append(ids, id)
	}
	return
}

// RepairinvoicesIDs returns the repairinvoices ids in the mutation.
func (m *EmployeeMutation) RepairinvoicesIDs() (ids []int) {
	for id := range m.repairinvoices {
		ids = append(ids, id)
	}
	return
}

// ResetRepairinvoices reset all changes of the "repairinvoices" edge.
func (m *EmployeeMutation) ResetRepairinvoices() {
	m.repairinvoices = nil
	m.removedrepairinvoices = nil
}

// AddCleaningroomIDs adds the cleaningrooms edge to Cleaningroom by ids.
func (m *EmployeeMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to Cleaningroom by ids.
func (m *EmployeeMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *EmployeeMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *EmployeeMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *EmployeeMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, employee.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldName:
		return m.Name()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.employees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	if m.leasess != nil {
		edges = append(edges, employee.EdgeLeasess)
	}
	if m.roomdetails != nil {
		edges = append(edges, employee.EdgeRoomdetails)
	}
	if m.jobposition != nil {
		edges = append(edges, employee.EdgeJobposition)
	}
	if m.repairinvoices != nil {
		edges = append(edges, employee.EdgeRepairinvoices)
	}
	if m.cleaningrooms != nil {
		edges = append(edges, employee.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeLeasess:
		ids := make([]ent.Value, 0, len(m.leasess))
		for id := range m.leasess {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeJobposition:
		if id := m.jobposition; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.repairinvoices))
		for id := range m.repairinvoices {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedemployees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	if m.removedleasess != nil {
		edges = append(edges, employee.EdgeLeasess)
	}
	if m.removedroomdetails != nil {
		edges = append(edges, employee.EdgeRoomdetails)
	}
	if m.removedrepairinvoices != nil {
		edges = append(edges, employee.EdgeRepairinvoices)
	}
	if m.removedcleaningrooms != nil {
		edges = append(edges, employee.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeLeasess:
		ids := make([]ent.Value, 0, len(m.removedleasess))
		for id := range m.removedleasess {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.removedrepairinvoices))
		for id := range m.removedrepairinvoices {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedjobposition {
		edges = append(edges, employee.EdgeJobposition)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeJobposition:
		return m.clearedjobposition
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeJobposition:
		m.ClearJobposition()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case employee.EdgeLeasess:
		m.ResetLeasess()
		return nil
	case employee.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	case employee.EdgeJobposition:
		m.ResetJobposition()
		return nil
	case employee.EdgeRepairinvoices:
		m.ResetRepairinvoices()
		return nil
	case employee.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// JobpositionMutation represents an operation that mutate the Jobpositions
// nodes in the graph.
type JobpositionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	positionname       *string
	clearedFields      map[string]struct{}
	employees          map[int]struct{}
	removedemployees   map[int]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Jobposition, error)
}

var _ ent.Mutation = (*JobpositionMutation)(nil)

// jobpositionOption allows to manage the mutation configuration using functional options.
type jobpositionOption func(*JobpositionMutation)

// newJobpositionMutation creates new mutation for $n.Name.
func newJobpositionMutation(c config, op Op, opts ...jobpositionOption) *JobpositionMutation {
	m := &JobpositionMutation{
		config:        c,
		op:            op,
		typ:           TypeJobposition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobpositionID sets the id field of the mutation.
func withJobpositionID(id int) jobpositionOption {
	return func(m *JobpositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Jobposition
		)
		m.oldValue = func(ctx context.Context) (*Jobposition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Jobposition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobposition sets the old Jobposition of the mutation.
func withJobposition(node *Jobposition) jobpositionOption {
	return func(m *JobpositionMutation) {
		m.oldValue = func(context.Context) (*Jobposition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobpositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobpositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *JobpositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPositionname sets the positionname field.
func (m *JobpositionMutation) SetPositionname(s string) {
	m.positionname = &s
}

// Positionname returns the positionname value in the mutation.
func (m *JobpositionMutation) Positionname() (r string, exists bool) {
	v := m.positionname
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionname returns the old positionname value of the Jobposition.
// If the Jobposition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *JobpositionMutation) OldPositionname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionname: %w", err)
	}
	return oldValue.Positionname, nil
}

// ResetPositionname reset all changes of the "positionname" field.
func (m *JobpositionMutation) ResetPositionname() {
	m.positionname = nil
}

// AddEmployeeIDs adds the employees edge to Employee by ids.
func (m *JobpositionMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Employee by ids.
func (m *JobpositionMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *JobpositionMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *JobpositionMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *JobpositionMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *JobpositionMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *JobpositionMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *JobpositionMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *JobpositionMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *JobpositionMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *JobpositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Jobposition).
func (m *JobpositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *JobpositionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.positionname != nil {
		fields = append(fields, jobposition.FieldPositionname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *JobpositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobposition.FieldPositionname:
		return m.Positionname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *JobpositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobposition.FieldPositionname:
		return m.OldPositionname(ctx)
	}
	return nil, fmt.Errorf("unknown Jobposition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *JobpositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobposition.FieldPositionname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionname(v)
		return nil
	}
	return fmt.Errorf("unknown Jobposition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *JobpositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *JobpositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *JobpositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Jobposition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *JobpositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *JobpositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobpositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Jobposition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *JobpositionMutation) ResetField(name string) error {
	switch name {
	case jobposition.FieldPositionname:
		m.ResetPositionname()
		return nil
	}
	return fmt.Errorf("unknown Jobposition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *JobpositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.employees != nil {
		edges = append(edges, jobposition.EdgeEmployees)
	}
	if m.roomdetails != nil {
		edges = append(edges, jobposition.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *JobpositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *JobpositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedemployees != nil {
		edges = append(edges, jobposition.EdgeEmployees)
	}
	if m.removedroomdetails != nil {
		edges = append(edges, jobposition.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *JobpositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *JobpositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *JobpositionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *JobpositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Jobposition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *JobpositionMutation) ResetEdge(name string) error {
	switch name {
	case jobposition.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case jobposition.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Jobposition edge %s", name)
}

// LeaseMutation represents an operation that mutate the Leases
// nodes in the graph.
type LeaseMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	addedtime             *time.Time
	tenant                *string
	numbtenant            *string
	idtenant              *string
	agetenant             *int
	addagetenant          *int
	clearedFields         map[string]struct{}
	_Wifi                 *int
	cleared_Wifi          bool
	_Roomdetail           *int
	cleared_Roomdetail    bool
	employee              *int
	clearedemployee       bool
	leases                map[int]struct{}
	removedleases         map[int]struct{}
	bill                  map[int]struct{}
	removedbill           map[int]struct{}
	repairinvoices        map[int]struct{}
	removedrepairinvoices map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Lease, error)
}

var _ ent.Mutation = (*LeaseMutation)(nil)

// leaseOption allows to manage the mutation configuration using functional options.
type leaseOption func(*LeaseMutation)

// newLeaseMutation creates new mutation for $n.Name.
func newLeaseMutation(c config, op Op, opts ...leaseOption) *LeaseMutation {
	m := &LeaseMutation{
		config:        c,
		op:            op,
		typ:           TypeLease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeaseID sets the id field of the mutation.
func withLeaseID(id int) leaseOption {
	return func(m *LeaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Lease
		)
		m.oldValue = func(ctx context.Context) (*Lease, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLease sets the old Lease of the mutation.
func withLease(node *Lease) leaseOption {
	return func(m *LeaseMutation) {
		m.oldValue = func(context.Context) (*Lease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LeaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *LeaseMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *LeaseMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Lease.
// If the Lease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LeaseMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *LeaseMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetTenant sets the tenant field.
func (m *LeaseMutation) SetTenant(s string) {
	m.tenant = &s
}

// Tenant returns the tenant value in the mutation.
func (m *LeaseMutation) Tenant() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenant returns the old tenant value of the Lease.
// If the Lease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LeaseMutation) OldTenant(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenant is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenant: %w", err)
	}
	return oldValue.Tenant, nil
}

// ResetTenant reset all changes of the "tenant" field.
func (m *LeaseMutation) ResetTenant() {
	m.tenant = nil
}

// SetNumbtenant sets the numbtenant field.
func (m *LeaseMutation) SetNumbtenant(s string) {
	m.numbtenant = &s
}

// Numbtenant returns the numbtenant value in the mutation.
func (m *LeaseMutation) Numbtenant() (r string, exists bool) {
	v := m.numbtenant
	if v == nil {
		return
	}
	return *v, true
}

// OldNumbtenant returns the old numbtenant value of the Lease.
// If the Lease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LeaseMutation) OldNumbtenant(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumbtenant is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumbtenant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumbtenant: %w", err)
	}
	return oldValue.Numbtenant, nil
}

// ResetNumbtenant reset all changes of the "numbtenant" field.
func (m *LeaseMutation) ResetNumbtenant() {
	m.numbtenant = nil
}

// SetIdtenant sets the idtenant field.
func (m *LeaseMutation) SetIdtenant(s string) {
	m.idtenant = &s
}

// Idtenant returns the idtenant value in the mutation.
func (m *LeaseMutation) Idtenant() (r string, exists bool) {
	v := m.idtenant
	if v == nil {
		return
	}
	return *v, true
}

// OldIdtenant returns the old idtenant value of the Lease.
// If the Lease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LeaseMutation) OldIdtenant(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIdtenant is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIdtenant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdtenant: %w", err)
	}
	return oldValue.Idtenant, nil
}

// ResetIdtenant reset all changes of the "idtenant" field.
func (m *LeaseMutation) ResetIdtenant() {
	m.idtenant = nil
}

// SetAgetenant sets the agetenant field.
func (m *LeaseMutation) SetAgetenant(i int) {
	m.agetenant = &i
	m.addagetenant = nil
}

// Agetenant returns the agetenant value in the mutation.
func (m *LeaseMutation) Agetenant() (r int, exists bool) {
	v := m.agetenant
	if v == nil {
		return
	}
	return *v, true
}

// OldAgetenant returns the old agetenant value of the Lease.
// If the Lease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LeaseMutation) OldAgetenant(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgetenant is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgetenant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgetenant: %w", err)
	}
	return oldValue.Agetenant, nil
}

// AddAgetenant adds i to agetenant.
func (m *LeaseMutation) AddAgetenant(i int) {
	if m.addagetenant != nil {
		*m.addagetenant += i
	} else {
		m.addagetenant = &i
	}
}

// AddedAgetenant returns the value that was added to the agetenant field in this mutation.
func (m *LeaseMutation) AddedAgetenant() (r int, exists bool) {
	v := m.addagetenant
	if v == nil {
		return
	}
	return *v, true
}

// ResetAgetenant reset all changes of the "agetenant" field.
func (m *LeaseMutation) ResetAgetenant() {
	m.agetenant = nil
	m.addagetenant = nil
}

// SetWifiID sets the Wifi edge to Wifi by id.
func (m *LeaseMutation) SetWifiID(id int) {
	m._Wifi = &id
}

// ClearWifi clears the Wifi edge to Wifi.
func (m *LeaseMutation) ClearWifi() {
	m.cleared_Wifi = true
}

// WifiCleared returns if the edge Wifi was cleared.
func (m *LeaseMutation) WifiCleared() bool {
	return m.cleared_Wifi
}

// WifiID returns the Wifi id in the mutation.
func (m *LeaseMutation) WifiID() (id int, exists bool) {
	if m._Wifi != nil {
		return *m._Wifi, true
	}
	return
}

// WifiIDs returns the Wifi ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WifiID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) WifiIDs() (ids []int) {
	if id := m._Wifi; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWifi reset all changes of the "Wifi" edge.
func (m *LeaseMutation) ResetWifi() {
	m._Wifi = nil
	m.cleared_Wifi = false
}

// SetRoomdetailID sets the Roomdetail edge to Roomdetail by id.
func (m *LeaseMutation) SetRoomdetailID(id int) {
	m._Roomdetail = &id
}

// ClearRoomdetail clears the Roomdetail edge to Roomdetail.
func (m *LeaseMutation) ClearRoomdetail() {
	m.cleared_Roomdetail = true
}

// RoomdetailCleared returns if the edge Roomdetail was cleared.
func (m *LeaseMutation) RoomdetailCleared() bool {
	return m.cleared_Roomdetail
}

// RoomdetailID returns the Roomdetail id in the mutation.
func (m *LeaseMutation) RoomdetailID() (id int, exists bool) {
	if m._Roomdetail != nil {
		return *m._Roomdetail, true
	}
	return
}

// RoomdetailIDs returns the Roomdetail ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomdetailID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) RoomdetailIDs() (ids []int) {
	if id := m._Roomdetail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomdetail reset all changes of the "Roomdetail" edge.
func (m *LeaseMutation) ResetRoomdetail() {
	m._Roomdetail = nil
	m.cleared_Roomdetail = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *LeaseMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *LeaseMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *LeaseMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *LeaseMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *LeaseMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// AddLeaseIDs adds the leases edge to Deposit by ids.
func (m *LeaseMutation) AddLeaseIDs(ids ...int) {
	if m.leases == nil {
		m.leases = make(map[int]struct{})
	}
	for i := range ids {
		m.leases[ids[i]] = struct{}{}
	}
}

// RemoveLeaseIDs removes the leases edge to Deposit by ids.
func (m *LeaseMutation) RemoveLeaseIDs(ids ...int) {
	if m.removedleases == nil {
		m.removedleases = make(map[int]struct{})
	}
	for i := range ids {
		m.removedleases[ids[i]] = struct{}{}
	}
}

// RemovedLeases returns the removed ids of leases.
func (m *LeaseMutation) RemovedLeasesIDs() (ids []int) {
	for id := range m.removedleases {
		ids = append(ids, id)
	}
	return
}

// LeasesIDs returns the leases ids in the mutation.
func (m *LeaseMutation) LeasesIDs() (ids []int) {
	for id := range m.leases {
		ids = append(ids, id)
	}
	return
}

// ResetLeases reset all changes of the "leases" edge.
func (m *LeaseMutation) ResetLeases() {
	m.leases = nil
	m.removedleases = nil
}

// AddBillIDs adds the bill edge to Bill by ids.
func (m *LeaseMutation) AddBillIDs(ids ...int) {
	if m.bill == nil {
		m.bill = make(map[int]struct{})
	}
	for i := range ids {
		m.bill[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the bill edge to Bill by ids.
func (m *LeaseMutation) RemoveBillIDs(ids ...int) {
	if m.removedbill == nil {
		m.removedbill = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbill[ids[i]] = struct{}{}
	}
}

// RemovedBill returns the removed ids of bill.
func (m *LeaseMutation) RemovedBillIDs() (ids []int) {
	for id := range m.removedbill {
		ids = append(ids, id)
	}
	return
}

// BillIDs returns the bill ids in the mutation.
func (m *LeaseMutation) BillIDs() (ids []int) {
	for id := range m.bill {
		ids = append(ids, id)
	}
	return
}

// ResetBill reset all changes of the "bill" edge.
func (m *LeaseMutation) ResetBill() {
	m.bill = nil
	m.removedbill = nil
}

// AddRepairinvoiceIDs adds the repairinvoices edge to Repairinvoice by ids.
func (m *LeaseMutation) AddRepairinvoiceIDs(ids ...int) {
	if m.repairinvoices == nil {
		m.repairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.repairinvoices[ids[i]] = struct{}{}
	}
}

// RemoveRepairinvoiceIDs removes the repairinvoices edge to Repairinvoice by ids.
func (m *LeaseMutation) RemoveRepairinvoiceIDs(ids ...int) {
	if m.removedrepairinvoices == nil {
		m.removedrepairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepairinvoices[ids[i]] = struct{}{}
	}
}

// RemovedRepairinvoices returns the removed ids of repairinvoices.
func (m *LeaseMutation) RemovedRepairinvoicesIDs() (ids []int) {
	for id := range m.removedrepairinvoices {
		ids = append(ids, id)
	}
	return
}

// RepairinvoicesIDs returns the repairinvoices ids in the mutation.
func (m *LeaseMutation) RepairinvoicesIDs() (ids []int) {
	for id := range m.repairinvoices {
		ids = append(ids, id)
	}
	return
}

// ResetRepairinvoices reset all changes of the "repairinvoices" edge.
func (m *LeaseMutation) ResetRepairinvoices() {
	m.repairinvoices = nil
	m.removedrepairinvoices = nil
}

// Op returns the operation name.
func (m *LeaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Lease).
func (m *LeaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LeaseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.addedtime != nil {
		fields = append(fields, lease.FieldAddedtime)
	}
	if m.tenant != nil {
		fields = append(fields, lease.FieldTenant)
	}
	if m.numbtenant != nil {
		fields = append(fields, lease.FieldNumbtenant)
	}
	if m.idtenant != nil {
		fields = append(fields, lease.FieldIdtenant)
	}
	if m.agetenant != nil {
		fields = append(fields, lease.FieldAgetenant)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LeaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lease.FieldAddedtime:
		return m.Addedtime()
	case lease.FieldTenant:
		return m.Tenant()
	case lease.FieldNumbtenant:
		return m.Numbtenant()
	case lease.FieldIdtenant:
		return m.Idtenant()
	case lease.FieldAgetenant:
		return m.Agetenant()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LeaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lease.FieldAddedtime:
		return m.OldAddedtime(ctx)
	case lease.FieldTenant:
		return m.OldTenant(ctx)
	case lease.FieldNumbtenant:
		return m.OldNumbtenant(ctx)
	case lease.FieldIdtenant:
		return m.OldIdtenant(ctx)
	case lease.FieldAgetenant:
		return m.OldAgetenant(ctx)
	}
	return nil, fmt.Errorf("unknown Lease field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LeaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lease.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	case lease.FieldTenant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenant(v)
		return nil
	case lease.FieldNumbtenant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumbtenant(v)
		return nil
	case lease.FieldIdtenant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdtenant(v)
		return nil
	case lease.FieldAgetenant:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgetenant(v)
		return nil
	}
	return fmt.Errorf("unknown Lease field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LeaseMutation) AddedFields() []string {
	var fields []string
	if m.addagetenant != nil {
		fields = append(fields, lease.FieldAgetenant)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LeaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lease.FieldAgetenant:
		return m.AddedAgetenant()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LeaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lease.FieldAgetenant:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgetenant(v)
		return nil
	}
	return fmt.Errorf("unknown Lease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LeaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LeaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Lease nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LeaseMutation) ResetField(name string) error {
	switch name {
	case lease.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	case lease.FieldTenant:
		m.ResetTenant()
		return nil
	case lease.FieldNumbtenant:
		m.ResetNumbtenant()
		return nil
	case lease.FieldIdtenant:
		m.ResetIdtenant()
		return nil
	case lease.FieldAgetenant:
		m.ResetAgetenant()
		return nil
	}
	return fmt.Errorf("unknown Lease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LeaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._Wifi != nil {
		edges = append(edges, lease.EdgeWifi)
	}
	if m._Roomdetail != nil {
		edges = append(edges, lease.EdgeRoomdetail)
	}
	if m.employee != nil {
		edges = append(edges, lease.EdgeEmployee)
	}
	if m.leases != nil {
		edges = append(edges, lease.EdgeLeases)
	}
	if m.bill != nil {
		edges = append(edges, lease.EdgeBill)
	}
	if m.repairinvoices != nil {
		edges = append(edges, lease.EdgeRepairinvoices)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LeaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lease.EdgeWifi:
		if id := m._Wifi; id != nil {
			return []ent.Value{*id}
		}
	case lease.EdgeRoomdetail:
		if id := m._Roomdetail; id != nil {
			return []ent.Value{*id}
		}
	case lease.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case lease.EdgeLeases:
		ids := make([]ent.Value, 0, len(m.leases))
		for id := range m.leases {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeBill:
		ids := make([]ent.Value, 0, len(m.bill))
		for id := range m.bill {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.repairinvoices))
		for id := range m.repairinvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LeaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedleases != nil {
		edges = append(edges, lease.EdgeLeases)
	}
	if m.removedbill != nil {
		edges = append(edges, lease.EdgeBill)
	}
	if m.removedrepairinvoices != nil {
		edges = append(edges, lease.EdgeRepairinvoices)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LeaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lease.EdgeLeases:
		ids := make([]ent.Value, 0, len(m.removedleases))
		for id := range m.removedleases {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeBill:
		ids := make([]ent.Value, 0, len(m.removedbill))
		for id := range m.removedbill {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.removedrepairinvoices))
		for id := range m.removedrepairinvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LeaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_Wifi {
		edges = append(edges, lease.EdgeWifi)
	}
	if m.cleared_Roomdetail {
		edges = append(edges, lease.EdgeRoomdetail)
	}
	if m.clearedemployee {
		edges = append(edges, lease.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LeaseMutation) EdgeCleared(name string) bool {
	switch name {
	case lease.EdgeWifi:
		return m.cleared_Wifi
	case lease.EdgeRoomdetail:
		return m.cleared_Roomdetail
	case lease.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LeaseMutation) ClearEdge(name string) error {
	switch name {
	case lease.EdgeWifi:
		m.ClearWifi()
		return nil
	case lease.EdgeRoomdetail:
		m.ClearRoomdetail()
		return nil
	case lease.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Lease unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LeaseMutation) ResetEdge(name string) error {
	switch name {
	case lease.EdgeWifi:
		m.ResetWifi()
		return nil
	case lease.EdgeRoomdetail:
		m.ResetRoomdetail()
		return nil
	case lease.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case lease.EdgeLeases:
		m.ResetLeases()
		return nil
	case lease.EdgeBill:
		m.ResetBill()
		return nil
	case lease.EdgeRepairinvoices:
		m.ResetRepairinvoices()
		return nil
	}
	return fmt.Errorf("unknown Lease edge %s", name)
}

// LengthtimeMutation represents an operation that mutate the Lengthtimes
// nodes in the graph.
type LengthtimeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	lengthtime           *string
	clearedFields        map[string]struct{}
	cleaningrooms        map[int]struct{}
	removedcleaningrooms map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Lengthtime, error)
}

var _ ent.Mutation = (*LengthtimeMutation)(nil)

// lengthtimeOption allows to manage the mutation configuration using functional options.
type lengthtimeOption func(*LengthtimeMutation)

// newLengthtimeMutation creates new mutation for $n.Name.
func newLengthtimeMutation(c config, op Op, opts ...lengthtimeOption) *LengthtimeMutation {
	m := &LengthtimeMutation{
		config:        c,
		op:            op,
		typ:           TypeLengthtime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLengthtimeID sets the id field of the mutation.
func withLengthtimeID(id int) lengthtimeOption {
	return func(m *LengthtimeMutation) {
		var (
			err   error
			once  sync.Once
			value *Lengthtime
		)
		m.oldValue = func(ctx context.Context) (*Lengthtime, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lengthtime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLengthtime sets the old Lengthtime of the mutation.
func withLengthtime(node *Lengthtime) lengthtimeOption {
	return func(m *LengthtimeMutation) {
		m.oldValue = func(context.Context) (*Lengthtime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LengthtimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LengthtimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LengthtimeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLengthtime sets the lengthtime field.
func (m *LengthtimeMutation) SetLengthtime(s string) {
	m.lengthtime = &s
}

// Lengthtime returns the lengthtime value in the mutation.
func (m *LengthtimeMutation) Lengthtime() (r string, exists bool) {
	v := m.lengthtime
	if v == nil {
		return
	}
	return *v, true
}

// OldLengthtime returns the old lengthtime value of the Lengthtime.
// If the Lengthtime object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LengthtimeMutation) OldLengthtime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLengthtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLengthtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLengthtime: %w", err)
	}
	return oldValue.Lengthtime, nil
}

// ResetLengthtime reset all changes of the "lengthtime" field.
func (m *LengthtimeMutation) ResetLengthtime() {
	m.lengthtime = nil
}

// AddCleaningroomIDs adds the cleaningrooms edge to Cleaningroom by ids.
func (m *LengthtimeMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to Cleaningroom by ids.
func (m *LengthtimeMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *LengthtimeMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *LengthtimeMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *LengthtimeMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *LengthtimeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Lengthtime).
func (m *LengthtimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LengthtimeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.lengthtime != nil {
		fields = append(fields, lengthtime.FieldLengthtime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LengthtimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lengthtime.FieldLengthtime:
		return m.Lengthtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LengthtimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lengthtime.FieldLengthtime:
		return m.OldLengthtime(ctx)
	}
	return nil, fmt.Errorf("unknown Lengthtime field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LengthtimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lengthtime.FieldLengthtime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLengthtime(v)
		return nil
	}
	return fmt.Errorf("unknown Lengthtime field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LengthtimeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LengthtimeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LengthtimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Lengthtime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LengthtimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LengthtimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LengthtimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Lengthtime nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LengthtimeMutation) ResetField(name string) error {
	switch name {
	case lengthtime.FieldLengthtime:
		m.ResetLengthtime()
		return nil
	}
	return fmt.Errorf("unknown Lengthtime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LengthtimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleaningrooms != nil {
		edges = append(edges, lengthtime.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LengthtimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lengthtime.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LengthtimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcleaningrooms != nil {
		edges = append(edges, lengthtime.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LengthtimeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lengthtime.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LengthtimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LengthtimeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LengthtimeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Lengthtime unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LengthtimeMutation) ResetEdge(name string) error {
	switch name {
	case lengthtime.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown Lengthtime edge %s", name)
}

// PaymentMutation represents an operation that mutate the Payments
// nodes in the graph.
type PaymentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	paymentname     *string
	clearedFields   map[string]struct{}
	payments        map[int]struct{}
	removedpayments map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Payment, error)
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows to manage the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for $n.Name.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the id field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPaymentname sets the paymentname field.
func (m *PaymentMutation) SetPaymentname(s string) {
	m.paymentname = &s
}

// Paymentname returns the paymentname value in the mutation.
func (m *PaymentMutation) Paymentname() (r string, exists bool) {
	v := m.paymentname
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentname returns the old paymentname value of the Payment.
// If the Payment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymentMutation) OldPaymentname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentname: %w", err)
	}
	return oldValue.Paymentname, nil
}

// ResetPaymentname reset all changes of the "paymentname" field.
func (m *PaymentMutation) ResetPaymentname() {
	m.paymentname = nil
}

// AddPaymentIDs adds the payments edge to Bill by ids.
func (m *PaymentMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payments edge to Bill by ids.
func (m *PaymentMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed ids of payments.
func (m *PaymentMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the payments ids in the mutation.
func (m *PaymentMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments reset all changes of the "payments" edge.
func (m *PaymentMutation) ResetPayments() {
	m.payments = nil
	m.removedpayments = nil
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.paymentname != nil {
		fields = append(fields, payment.FieldPaymentname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldPaymentname:
		return m.Paymentname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldPaymentname:
		return m.OldPaymentname(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldPaymentname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentname(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldPaymentname:
		m.ResetPaymentname()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payments != nil {
		edges = append(edges, payment.EdgePayments)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpayments != nil {
		edges = append(edges, payment.EdgePayments)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgePayments:
		m.ResetPayments()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PetruleMutation represents an operation that mutate the Petrules
// nodes in the graph.
type PetruleMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	petrule            *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Petrule, error)
}

var _ ent.Mutation = (*PetruleMutation)(nil)

// petruleOption allows to manage the mutation configuration using functional options.
type petruleOption func(*PetruleMutation)

// newPetruleMutation creates new mutation for $n.Name.
func newPetruleMutation(c config, op Op, opts ...petruleOption) *PetruleMutation {
	m := &PetruleMutation{
		config:        c,
		op:            op,
		typ:           TypePetrule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPetruleID sets the id field of the mutation.
func withPetruleID(id int) petruleOption {
	return func(m *PetruleMutation) {
		var (
			err   error
			once  sync.Once
			value *Petrule
		)
		m.oldValue = func(ctx context.Context) (*Petrule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Petrule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPetrule sets the old Petrule of the mutation.
func withPetrule(node *Petrule) petruleOption {
	return func(m *PetruleMutation) {
		m.oldValue = func(context.Context) (*Petrule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PetruleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PetruleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PetruleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPetrule sets the petrule field.
func (m *PetruleMutation) SetPetrule(s string) {
	m.petrule = &s
}

// Petrule returns the petrule value in the mutation.
func (m *PetruleMutation) Petrule() (r string, exists bool) {
	v := m.petrule
	if v == nil {
		return
	}
	return *v, true
}

// OldPetrule returns the old petrule value of the Petrule.
// If the Petrule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PetruleMutation) OldPetrule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPetrule is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPetrule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPetrule: %w", err)
	}
	return oldValue.Petrule, nil
}

// ResetPetrule reset all changes of the "petrule" field.
func (m *PetruleMutation) ResetPetrule() {
	m.petrule = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *PetruleMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *PetruleMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *PetruleMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *PetruleMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *PetruleMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *PetruleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Petrule).
func (m *PetruleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PetruleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.petrule != nil {
		fields = append(fields, petrule.FieldPetrule)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PetruleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case petrule.FieldPetrule:
		return m.Petrule()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PetruleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case petrule.FieldPetrule:
		return m.OldPetrule(ctx)
	}
	return nil, fmt.Errorf("unknown Petrule field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PetruleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case petrule.FieldPetrule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPetrule(v)
		return nil
	}
	return fmt.Errorf("unknown Petrule field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PetruleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PetruleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PetruleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Petrule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PetruleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PetruleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PetruleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Petrule nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PetruleMutation) ResetField(name string) error {
	switch name {
	case petrule.FieldPetrule:
		m.ResetPetrule()
		return nil
	}
	return fmt.Errorf("unknown Petrule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PetruleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, petrule.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PetruleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case petrule.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PetruleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, petrule.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PetruleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case petrule.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PetruleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PetruleMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PetruleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Petrule unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PetruleMutation) ResetEdge(name string) error {
	switch name {
	case petrule.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Petrule edge %s", name)
}

// PledgeMutation represents an operation that mutate the Pledges
// nodes in the graph.
type PledgeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	provision          *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Pledge, error)
}

var _ ent.Mutation = (*PledgeMutation)(nil)

// pledgeOption allows to manage the mutation configuration using functional options.
type pledgeOption func(*PledgeMutation)

// newPledgeMutation creates new mutation for $n.Name.
func newPledgeMutation(c config, op Op, opts ...pledgeOption) *PledgeMutation {
	m := &PledgeMutation{
		config:        c,
		op:            op,
		typ:           TypePledge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPledgeID sets the id field of the mutation.
func withPledgeID(id int) pledgeOption {
	return func(m *PledgeMutation) {
		var (
			err   error
			once  sync.Once
			value *Pledge
		)
		m.oldValue = func(ctx context.Context) (*Pledge, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pledge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPledge sets the old Pledge of the mutation.
func withPledge(node *Pledge) pledgeOption {
	return func(m *PledgeMutation) {
		m.oldValue = func(context.Context) (*Pledge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PledgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PledgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PledgeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProvision sets the provision field.
func (m *PledgeMutation) SetProvision(s string) {
	m.provision = &s
}

// Provision returns the provision value in the mutation.
func (m *PledgeMutation) Provision() (r string, exists bool) {
	v := m.provision
	if v == nil {
		return
	}
	return *v, true
}

// OldProvision returns the old provision value of the Pledge.
// If the Pledge object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PledgeMutation) OldProvision(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvision is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvision: %w", err)
	}
	return oldValue.Provision, nil
}

// ResetProvision reset all changes of the "provision" field.
func (m *PledgeMutation) ResetProvision() {
	m.provision = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *PledgeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *PledgeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *PledgeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *PledgeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *PledgeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *PledgeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pledge).
func (m *PledgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PledgeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.provision != nil {
		fields = append(fields, pledge.FieldProvision)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PledgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pledge.FieldProvision:
		return m.Provision()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PledgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pledge.FieldProvision:
		return m.OldProvision(ctx)
	}
	return nil, fmt.Errorf("unknown Pledge field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PledgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pledge.FieldProvision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvision(v)
		return nil
	}
	return fmt.Errorf("unknown Pledge field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PledgeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PledgeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PledgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pledge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PledgeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PledgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PledgeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pledge nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PledgeMutation) ResetField(name string) error {
	switch name {
	case pledge.FieldProvision:
		m.ResetProvision()
		return nil
	}
	return fmt.Errorf("unknown Pledge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PledgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, pledge.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PledgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pledge.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PledgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, pledge.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PledgeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pledge.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PledgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PledgeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PledgeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Pledge unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PledgeMutation) ResetEdge(name string) error {
	switch name {
	case pledge.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Pledge edge %s", name)
}

// RentalstatusMutation represents an operation that mutate the Rentalstatuses
// nodes in the graph.
type RentalstatusMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	rentalstatus          *string
	clearedFields         map[string]struct{}
	repairinvoices        map[int]struct{}
	removedrepairinvoices map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Rentalstatus, error)
}

var _ ent.Mutation = (*RentalstatusMutation)(nil)

// rentalstatusOption allows to manage the mutation configuration using functional options.
type rentalstatusOption func(*RentalstatusMutation)

// newRentalstatusMutation creates new mutation for $n.Name.
func newRentalstatusMutation(c config, op Op, opts ...rentalstatusOption) *RentalstatusMutation {
	m := &RentalstatusMutation{
		config:        c,
		op:            op,
		typ:           TypeRentalstatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRentalstatusID sets the id field of the mutation.
func withRentalstatusID(id int) rentalstatusOption {
	return func(m *RentalstatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Rentalstatus
		)
		m.oldValue = func(ctx context.Context) (*Rentalstatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rentalstatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRentalstatus sets the old Rentalstatus of the mutation.
func withRentalstatus(node *Rentalstatus) rentalstatusOption {
	return func(m *RentalstatusMutation) {
		m.oldValue = func(context.Context) (*Rentalstatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RentalstatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RentalstatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RentalstatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRentalstatus sets the rentalstatus field.
func (m *RentalstatusMutation) SetRentalstatus(s string) {
	m.rentalstatus = &s
}

// Rentalstatus returns the rentalstatus value in the mutation.
func (m *RentalstatusMutation) Rentalstatus() (r string, exists bool) {
	v := m.rentalstatus
	if v == nil {
		return
	}
	return *v, true
}

// OldRentalstatus returns the old rentalstatus value of the Rentalstatus.
// If the Rentalstatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RentalstatusMutation) OldRentalstatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRentalstatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRentalstatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRentalstatus: %w", err)
	}
	return oldValue.Rentalstatus, nil
}

// ResetRentalstatus reset all changes of the "rentalstatus" field.
func (m *RentalstatusMutation) ResetRentalstatus() {
	m.rentalstatus = nil
}

// AddRepairinvoiceIDs adds the repairinvoices edge to Repairinvoice by ids.
func (m *RentalstatusMutation) AddRepairinvoiceIDs(ids ...int) {
	if m.repairinvoices == nil {
		m.repairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.repairinvoices[ids[i]] = struct{}{}
	}
}

// RemoveRepairinvoiceIDs removes the repairinvoices edge to Repairinvoice by ids.
func (m *RentalstatusMutation) RemoveRepairinvoiceIDs(ids ...int) {
	if m.removedrepairinvoices == nil {
		m.removedrepairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepairinvoices[ids[i]] = struct{}{}
	}
}

// RemovedRepairinvoices returns the removed ids of repairinvoices.
func (m *RentalstatusMutation) RemovedRepairinvoicesIDs() (ids []int) {
	for id := range m.removedrepairinvoices {
		ids = append(ids, id)
	}
	return
}

// RepairinvoicesIDs returns the repairinvoices ids in the mutation.
func (m *RentalstatusMutation) RepairinvoicesIDs() (ids []int) {
	for id := range m.repairinvoices {
		ids = append(ids, id)
	}
	return
}

// ResetRepairinvoices reset all changes of the "repairinvoices" edge.
func (m *RentalstatusMutation) ResetRepairinvoices() {
	m.repairinvoices = nil
	m.removedrepairinvoices = nil
}

// Op returns the operation name.
func (m *RentalstatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Rentalstatus).
func (m *RentalstatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RentalstatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.rentalstatus != nil {
		fields = append(fields, rentalstatus.FieldRentalstatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RentalstatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rentalstatus.FieldRentalstatus:
		return m.Rentalstatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RentalstatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rentalstatus.FieldRentalstatus:
		return m.OldRentalstatus(ctx)
	}
	return nil, fmt.Errorf("unknown Rentalstatus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RentalstatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rentalstatus.FieldRentalstatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRentalstatus(v)
		return nil
	}
	return fmt.Errorf("unknown Rentalstatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RentalstatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RentalstatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RentalstatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rentalstatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RentalstatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RentalstatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RentalstatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Rentalstatus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RentalstatusMutation) ResetField(name string) error {
	switch name {
	case rentalstatus.FieldRentalstatus:
		m.ResetRentalstatus()
		return nil
	}
	return fmt.Errorf("unknown Rentalstatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RentalstatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repairinvoices != nil {
		edges = append(edges, rentalstatus.EdgeRepairinvoices)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RentalstatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rentalstatus.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.repairinvoices))
		for id := range m.repairinvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RentalstatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrepairinvoices != nil {
		edges = append(edges, rentalstatus.EdgeRepairinvoices)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RentalstatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rentalstatus.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.removedrepairinvoices))
		for id := range m.removedrepairinvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RentalstatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RentalstatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RentalstatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Rentalstatus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RentalstatusMutation) ResetEdge(name string) error {
	switch name {
	case rentalstatus.EdgeRepairinvoices:
		m.ResetRepairinvoices()
		return nil
	}
	return fmt.Errorf("unknown Rentalstatus edge %s", name)
}

// RepairinvoiceMutation represents an operation that mutate the Repairinvoices
// nodes in the graph.
type RepairinvoiceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	bequipment           *string
	emtell               *string
	num                  *int
	addnum               *int
	clearedFields        map[string]struct{}
	employee             *int
	clearedemployee      bool
	_Rentalstatus        *int
	cleared_Rentalstatus bool
	_Lease               *int
	cleared_Lease        bool
	done                 bool
	oldValue             func(context.Context) (*Repairinvoice, error)
}

var _ ent.Mutation = (*RepairinvoiceMutation)(nil)

// repairinvoiceOption allows to manage the mutation configuration using functional options.
type repairinvoiceOption func(*RepairinvoiceMutation)

// newRepairinvoiceMutation creates new mutation for $n.Name.
func newRepairinvoiceMutation(c config, op Op, opts ...repairinvoiceOption) *RepairinvoiceMutation {
	m := &RepairinvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeRepairinvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepairinvoiceID sets the id field of the mutation.
func withRepairinvoiceID(id int) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Repairinvoice
		)
		m.oldValue = func(ctx context.Context) (*Repairinvoice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repairinvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepairinvoice sets the old Repairinvoice of the mutation.
func withRepairinvoice(node *Repairinvoice) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		m.oldValue = func(context.Context) (*Repairinvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepairinvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepairinvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RepairinvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBequipment sets the bequipment field.
func (m *RepairinvoiceMutation) SetBequipment(s string) {
	m.bequipment = &s
}

// Bequipment returns the bequipment value in the mutation.
func (m *RepairinvoiceMutation) Bequipment() (r string, exists bool) {
	v := m.bequipment
	if v == nil {
		return
	}
	return *v, true
}

// OldBequipment returns the old bequipment value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldBequipment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBequipment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBequipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBequipment: %w", err)
	}
	return oldValue.Bequipment, nil
}

// ResetBequipment reset all changes of the "bequipment" field.
func (m *RepairinvoiceMutation) ResetBequipment() {
	m.bequipment = nil
}

// SetEmtell sets the emtell field.
func (m *RepairinvoiceMutation) SetEmtell(s string) {
	m.emtell = &s
}

// Emtell returns the emtell value in the mutation.
func (m *RepairinvoiceMutation) Emtell() (r string, exists bool) {
	v := m.emtell
	if v == nil {
		return
	}
	return *v, true
}

// OldEmtell returns the old emtell value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldEmtell(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmtell is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmtell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmtell: %w", err)
	}
	return oldValue.Emtell, nil
}

// ResetEmtell reset all changes of the "emtell" field.
func (m *RepairinvoiceMutation) ResetEmtell() {
	m.emtell = nil
}

// SetNum sets the num field.
func (m *RepairinvoiceMutation) SetNum(i int) {
	m.num = &i
	m.addnum = nil
}

// Num returns the num value in the mutation.
func (m *RepairinvoiceMutation) Num() (r int, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old num value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNum is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to num.
func (m *RepairinvoiceMutation) AddNum(i int) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the num field in this mutation.
func (m *RepairinvoiceMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum reset all changes of the "num" field.
func (m *RepairinvoiceMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *RepairinvoiceMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *RepairinvoiceMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *RepairinvoiceMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *RepairinvoiceMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *RepairinvoiceMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *RepairinvoiceMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetRentalstatusID sets the Rentalstatus edge to Rentalstatus by id.
func (m *RepairinvoiceMutation) SetRentalstatusID(id int) {
	m._Rentalstatus = &id
}

// ClearRentalstatus clears the Rentalstatus edge to Rentalstatus.
func (m *RepairinvoiceMutation) ClearRentalstatus() {
	m.cleared_Rentalstatus = true
}

// RentalstatusCleared returns if the edge Rentalstatus was cleared.
func (m *RepairinvoiceMutation) RentalstatusCleared() bool {
	return m.cleared_Rentalstatus
}

// RentalstatusID returns the Rentalstatus id in the mutation.
func (m *RepairinvoiceMutation) RentalstatusID() (id int, exists bool) {
	if m._Rentalstatus != nil {
		return *m._Rentalstatus, true
	}
	return
}

// RentalstatusIDs returns the Rentalstatus ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RentalstatusID instead. It exists only for internal usage by the builders.
func (m *RepairinvoiceMutation) RentalstatusIDs() (ids []int) {
	if id := m._Rentalstatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRentalstatus reset all changes of the "Rentalstatus" edge.
func (m *RepairinvoiceMutation) ResetRentalstatus() {
	m._Rentalstatus = nil
	m.cleared_Rentalstatus = false
}

// SetLeaseID sets the Lease edge to Lease by id.
func (m *RepairinvoiceMutation) SetLeaseID(id int) {
	m._Lease = &id
}

// ClearLease clears the Lease edge to Lease.
func (m *RepairinvoiceMutation) ClearLease() {
	m.cleared_Lease = true
}

// LeaseCleared returns if the edge Lease was cleared.
func (m *RepairinvoiceMutation) LeaseCleared() bool {
	return m.cleared_Lease
}

// LeaseID returns the Lease id in the mutation.
func (m *RepairinvoiceMutation) LeaseID() (id int, exists bool) {
	if m._Lease != nil {
		return *m._Lease, true
	}
	return
}

// LeaseIDs returns the Lease ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LeaseID instead. It exists only for internal usage by the builders.
func (m *RepairinvoiceMutation) LeaseIDs() (ids []int) {
	if id := m._Lease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLease reset all changes of the "Lease" edge.
func (m *RepairinvoiceMutation) ResetLease() {
	m._Lease = nil
	m.cleared_Lease = false
}

// Op returns the operation name.
func (m *RepairinvoiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repairinvoice).
func (m *RepairinvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RepairinvoiceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.bequipment != nil {
		fields = append(fields, repairinvoice.FieldBequipment)
	}
	if m.emtell != nil {
		fields = append(fields, repairinvoice.FieldEmtell)
	}
	if m.num != nil {
		fields = append(fields, repairinvoice.FieldNum)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RepairinvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldBequipment:
		return m.Bequipment()
	case repairinvoice.FieldEmtell:
		return m.Emtell()
	case repairinvoice.FieldNum:
		return m.Num()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RepairinvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repairinvoice.FieldBequipment:
		return m.OldBequipment(ctx)
	case repairinvoice.FieldEmtell:
		return m.OldEmtell(ctx)
	case repairinvoice.FieldNum:
		return m.OldNum(ctx)
	}
	return nil, fmt.Errorf("unknown Repairinvoice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldBequipment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBequipment(v)
		return nil
	case repairinvoice.FieldEmtell:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmtell(v)
		return nil
	case repairinvoice.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RepairinvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addnum != nil {
		fields = append(fields, repairinvoice.FieldNum)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RepairinvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldNum:
		return m.AddedNum()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RepairinvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RepairinvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepairinvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repairinvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetField(name string) error {
	switch name {
	case repairinvoice.FieldBequipment:
		m.ResetBequipment()
		return nil
	case repairinvoice.FieldEmtell:
		m.ResetEmtell()
		return nil
	case repairinvoice.FieldNum:
		m.ResetNum()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RepairinvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.employee != nil {
		edges = append(edges, repairinvoice.EdgeEmployee)
	}
	if m._Rentalstatus != nil {
		edges = append(edges, repairinvoice.EdgeRentalstatus)
	}
	if m._Lease != nil {
		edges = append(edges, repairinvoice.EdgeLease)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RepairinvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repairinvoice.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case repairinvoice.EdgeRentalstatus:
		if id := m._Rentalstatus; id != nil {
			return []ent.Value{*id}
		}
	case repairinvoice.EdgeLease:
		if id := m._Lease; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RepairinvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RepairinvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RepairinvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedemployee {
		edges = append(edges, repairinvoice.EdgeEmployee)
	}
	if m.cleared_Rentalstatus {
		edges = append(edges, repairinvoice.EdgeRentalstatus)
	}
	if m.cleared_Lease {
		edges = append(edges, repairinvoice.EdgeLease)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RepairinvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case repairinvoice.EdgeEmployee:
		return m.clearedemployee
	case repairinvoice.EdgeRentalstatus:
		return m.cleared_Rentalstatus
	case repairinvoice.EdgeLease:
		return m.cleared_Lease
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RepairinvoiceMutation) ClearEdge(name string) error {
	switch name {
	case repairinvoice.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case repairinvoice.EdgeRentalstatus:
		m.ClearRentalstatus()
		return nil
	case repairinvoice.EdgeLease:
		m.ClearLease()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetEdge(name string) error {
	switch name {
	case repairinvoice.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case repairinvoice.EdgeRentalstatus:
		m.ResetRentalstatus()
		return nil
	case repairinvoice.EdgeLease:
		m.ResetLease()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice edge %s", name)
}

// RoomdetailMutation represents an operation that mutate the Roomdetails
// nodes in the graph.
type RoomdetailMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	roomnumber           *string
	roomtypename         *string
	roomprice            *int
	addroomprice         *int
	phone                *string
	sleep                *int
	addsleep             *int
	bed                  *int
	addbed               *int
	clearedFields        map[string]struct{}
	pledge               *int
	clearedpledge        bool
	petrule              *int
	clearedpetrule       bool
	bedtype              *int
	clearedbedtype       bool
	employee             *int
	clearedemployee      bool
	jobposition          *int
	clearedjobposition   bool
	staytype             *int
	clearedstaytype      bool
	roomdetails          *int
	clearedroomdetails   bool
	cleaningrooms        map[int]struct{}
	removedcleaningrooms map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Roomdetail, error)
}

var _ ent.Mutation = (*RoomdetailMutation)(nil)

// roomdetailOption allows to manage the mutation configuration using functional options.
type roomdetailOption func(*RoomdetailMutation)

// newRoomdetailMutation creates new mutation for $n.Name.
func newRoomdetailMutation(c config, op Op, opts ...roomdetailOption) *RoomdetailMutation {
	m := &RoomdetailMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomdetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomdetailID sets the id field of the mutation.
func withRoomdetailID(id int) roomdetailOption {
	return func(m *RoomdetailMutation) {
		var (
			err   error
			once  sync.Once
			value *Roomdetail
		)
		m.oldValue = func(ctx context.Context) (*Roomdetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Roomdetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomdetail sets the old Roomdetail of the mutation.
func withRoomdetail(node *Roomdetail) roomdetailOption {
	return func(m *RoomdetailMutation) {
		m.oldValue = func(context.Context) (*Roomdetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomdetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomdetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomdetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomnumber sets the roomnumber field.
func (m *RoomdetailMutation) SetRoomnumber(s string) {
	m.roomnumber = &s
}

// Roomnumber returns the roomnumber value in the mutation.
func (m *RoomdetailMutation) Roomnumber() (r string, exists bool) {
	v := m.roomnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomnumber returns the old roomnumber value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldRoomnumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomnumber: %w", err)
	}
	return oldValue.Roomnumber, nil
}

// ResetRoomnumber reset all changes of the "roomnumber" field.
func (m *RoomdetailMutation) ResetRoomnumber() {
	m.roomnumber = nil
}

// SetRoomtypename sets the roomtypename field.
func (m *RoomdetailMutation) SetRoomtypename(s string) {
	m.roomtypename = &s
}

// Roomtypename returns the roomtypename value in the mutation.
func (m *RoomdetailMutation) Roomtypename() (r string, exists bool) {
	v := m.roomtypename
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomtypename returns the old roomtypename value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldRoomtypename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomtypename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomtypename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomtypename: %w", err)
	}
	return oldValue.Roomtypename, nil
}

// ResetRoomtypename reset all changes of the "roomtypename" field.
func (m *RoomdetailMutation) ResetRoomtypename() {
	m.roomtypename = nil
}

// SetRoomprice sets the roomprice field.
func (m *RoomdetailMutation) SetRoomprice(i int) {
	m.roomprice = &i
	m.addroomprice = nil
}

// Roomprice returns the roomprice value in the mutation.
func (m *RoomdetailMutation) Roomprice() (r int, exists bool) {
	v := m.roomprice
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomprice returns the old roomprice value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldRoomprice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomprice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomprice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomprice: %w", err)
	}
	return oldValue.Roomprice, nil
}

// AddRoomprice adds i to roomprice.
func (m *RoomdetailMutation) AddRoomprice(i int) {
	if m.addroomprice != nil {
		*m.addroomprice += i
	} else {
		m.addroomprice = &i
	}
}

// AddedRoomprice returns the value that was added to the roomprice field in this mutation.
func (m *RoomdetailMutation) AddedRoomprice() (r int, exists bool) {
	v := m.addroomprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoomprice reset all changes of the "roomprice" field.
func (m *RoomdetailMutation) ResetRoomprice() {
	m.roomprice = nil
	m.addroomprice = nil
}

// SetPhone sets the phone field.
func (m *RoomdetailMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *RoomdetailMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone reset all changes of the "phone" field.
func (m *RoomdetailMutation) ResetPhone() {
	m.phone = nil
}

// SetSleep sets the sleep field.
func (m *RoomdetailMutation) SetSleep(i int) {
	m.sleep = &i
	m.addsleep = nil
}

// Sleep returns the sleep value in the mutation.
func (m *RoomdetailMutation) Sleep() (r int, exists bool) {
	v := m.sleep
	if v == nil {
		return
	}
	return *v, true
}

// OldSleep returns the old sleep value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldSleep(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSleep is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSleep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSleep: %w", err)
	}
	return oldValue.Sleep, nil
}

// AddSleep adds i to sleep.
func (m *RoomdetailMutation) AddSleep(i int) {
	if m.addsleep != nil {
		*m.addsleep += i
	} else {
		m.addsleep = &i
	}
}

// AddedSleep returns the value that was added to the sleep field in this mutation.
func (m *RoomdetailMutation) AddedSleep() (r int, exists bool) {
	v := m.addsleep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSleep reset all changes of the "sleep" field.
func (m *RoomdetailMutation) ResetSleep() {
	m.sleep = nil
	m.addsleep = nil
}

// SetBed sets the bed field.
func (m *RoomdetailMutation) SetBed(i int) {
	m.bed = &i
	m.addbed = nil
}

// Bed returns the bed value in the mutation.
func (m *RoomdetailMutation) Bed() (r int, exists bool) {
	v := m.bed
	if v == nil {
		return
	}
	return *v, true
}

// OldBed returns the old bed value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldBed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBed: %w", err)
	}
	return oldValue.Bed, nil
}

// AddBed adds i to bed.
func (m *RoomdetailMutation) AddBed(i int) {
	if m.addbed != nil {
		*m.addbed += i
	} else {
		m.addbed = &i
	}
}

// AddedBed returns the value that was added to the bed field in this mutation.
func (m *RoomdetailMutation) AddedBed() (r int, exists bool) {
	v := m.addbed
	if v == nil {
		return
	}
	return *v, true
}

// ResetBed reset all changes of the "bed" field.
func (m *RoomdetailMutation) ResetBed() {
	m.bed = nil
	m.addbed = nil
}

// SetPledgeID sets the pledge edge to Pledge by id.
func (m *RoomdetailMutation) SetPledgeID(id int) {
	m.pledge = &id
}

// ClearPledge clears the pledge edge to Pledge.
func (m *RoomdetailMutation) ClearPledge() {
	m.clearedpledge = true
}

// PledgeCleared returns if the edge pledge was cleared.
func (m *RoomdetailMutation) PledgeCleared() bool {
	return m.clearedpledge
}

// PledgeID returns the pledge id in the mutation.
func (m *RoomdetailMutation) PledgeID() (id int, exists bool) {
	if m.pledge != nil {
		return *m.pledge, true
	}
	return
}

// PledgeIDs returns the pledge ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PledgeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) PledgeIDs() (ids []int) {
	if id := m.pledge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPledge reset all changes of the "pledge" edge.
func (m *RoomdetailMutation) ResetPledge() {
	m.pledge = nil
	m.clearedpledge = false
}

// SetPetruleID sets the petrule edge to Petrule by id.
func (m *RoomdetailMutation) SetPetruleID(id int) {
	m.petrule = &id
}

// ClearPetrule clears the petrule edge to Petrule.
func (m *RoomdetailMutation) ClearPetrule() {
	m.clearedpetrule = true
}

// PetruleCleared returns if the edge petrule was cleared.
func (m *RoomdetailMutation) PetruleCleared() bool {
	return m.clearedpetrule
}

// PetruleID returns the petrule id in the mutation.
func (m *RoomdetailMutation) PetruleID() (id int, exists bool) {
	if m.petrule != nil {
		return *m.petrule, true
	}
	return
}

// PetruleIDs returns the petrule ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PetruleID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) PetruleIDs() (ids []int) {
	if id := m.petrule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPetrule reset all changes of the "petrule" edge.
func (m *RoomdetailMutation) ResetPetrule() {
	m.petrule = nil
	m.clearedpetrule = false
}

// SetBedtypeID sets the bedtype edge to Bedtype by id.
func (m *RoomdetailMutation) SetBedtypeID(id int) {
	m.bedtype = &id
}

// ClearBedtype clears the bedtype edge to Bedtype.
func (m *RoomdetailMutation) ClearBedtype() {
	m.clearedbedtype = true
}

// BedtypeCleared returns if the edge bedtype was cleared.
func (m *RoomdetailMutation) BedtypeCleared() bool {
	return m.clearedbedtype
}

// BedtypeID returns the bedtype id in the mutation.
func (m *RoomdetailMutation) BedtypeID() (id int, exists bool) {
	if m.bedtype != nil {
		return *m.bedtype, true
	}
	return
}

// BedtypeIDs returns the bedtype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BedtypeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) BedtypeIDs() (ids []int) {
	if id := m.bedtype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBedtype reset all changes of the "bedtype" edge.
func (m *RoomdetailMutation) ResetBedtype() {
	m.bedtype = nil
	m.clearedbedtype = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *RoomdetailMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *RoomdetailMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *RoomdetailMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *RoomdetailMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *RoomdetailMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetJobpositionID sets the jobposition edge to Jobposition by id.
func (m *RoomdetailMutation) SetJobpositionID(id int) {
	m.jobposition = &id
}

// ClearJobposition clears the jobposition edge to Jobposition.
func (m *RoomdetailMutation) ClearJobposition() {
	m.clearedjobposition = true
}

// JobpositionCleared returns if the edge jobposition was cleared.
func (m *RoomdetailMutation) JobpositionCleared() bool {
	return m.clearedjobposition
}

// JobpositionID returns the jobposition id in the mutation.
func (m *RoomdetailMutation) JobpositionID() (id int, exists bool) {
	if m.jobposition != nil {
		return *m.jobposition, true
	}
	return
}

// JobpositionIDs returns the jobposition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// JobpositionID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) JobpositionIDs() (ids []int) {
	if id := m.jobposition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobposition reset all changes of the "jobposition" edge.
func (m *RoomdetailMutation) ResetJobposition() {
	m.jobposition = nil
	m.clearedjobposition = false
}

// SetStaytypeID sets the staytype edge to Staytype by id.
func (m *RoomdetailMutation) SetStaytypeID(id int) {
	m.staytype = &id
}

// ClearStaytype clears the staytype edge to Staytype.
func (m *RoomdetailMutation) ClearStaytype() {
	m.clearedstaytype = true
}

// StaytypeCleared returns if the edge staytype was cleared.
func (m *RoomdetailMutation) StaytypeCleared() bool {
	return m.clearedstaytype
}

// StaytypeID returns the staytype id in the mutation.
func (m *RoomdetailMutation) StaytypeID() (id int, exists bool) {
	if m.staytype != nil {
		return *m.staytype, true
	}
	return
}

// StaytypeIDs returns the staytype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StaytypeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) StaytypeIDs() (ids []int) {
	if id := m.staytype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaytype reset all changes of the "staytype" edge.
func (m *RoomdetailMutation) ResetStaytype() {
	m.staytype = nil
	m.clearedstaytype = false
}

// SetRoomdetailsID sets the roomdetails edge to Lease by id.
func (m *RoomdetailMutation) SetRoomdetailsID(id int) {
	m.roomdetails = &id
}

// ClearRoomdetails clears the roomdetails edge to Lease.
func (m *RoomdetailMutation) ClearRoomdetails() {
	m.clearedroomdetails = true
}

// RoomdetailsCleared returns if the edge roomdetails was cleared.
func (m *RoomdetailMutation) RoomdetailsCleared() bool {
	return m.clearedroomdetails
}

// RoomdetailsID returns the roomdetails id in the mutation.
func (m *RoomdetailMutation) RoomdetailsID() (id int, exists bool) {
	if m.roomdetails != nil {
		return *m.roomdetails, true
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomdetailsID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) RoomdetailsIDs() (ids []int) {
	if id := m.roomdetails; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *RoomdetailMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.clearedroomdetails = false
}

// AddCleaningroomIDs adds the cleaningrooms edge to Cleaningroom by ids.
func (m *RoomdetailMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to Cleaningroom by ids.
func (m *RoomdetailMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *RoomdetailMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *RoomdetailMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *RoomdetailMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *RoomdetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Roomdetail).
func (m *RoomdetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomdetailMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.roomnumber != nil {
		fields = append(fields, roomdetail.FieldRoomnumber)
	}
	if m.roomtypename != nil {
		fields = append(fields, roomdetail.FieldRoomtypename)
	}
	if m.roomprice != nil {
		fields = append(fields, roomdetail.FieldRoomprice)
	}
	if m.phone != nil {
		fields = append(fields, roomdetail.FieldPhone)
	}
	if m.sleep != nil {
		fields = append(fields, roomdetail.FieldSleep)
	}
	if m.bed != nil {
		fields = append(fields, roomdetail.FieldBed)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomdetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomdetail.FieldRoomnumber:
		return m.Roomnumber()
	case roomdetail.FieldRoomtypename:
		return m.Roomtypename()
	case roomdetail.FieldRoomprice:
		return m.Roomprice()
	case roomdetail.FieldPhone:
		return m.Phone()
	case roomdetail.FieldSleep:
		return m.Sleep()
	case roomdetail.FieldBed:
		return m.Bed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomdetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomdetail.FieldRoomnumber:
		return m.OldRoomnumber(ctx)
	case roomdetail.FieldRoomtypename:
		return m.OldRoomtypename(ctx)
	case roomdetail.FieldRoomprice:
		return m.OldRoomprice(ctx)
	case roomdetail.FieldPhone:
		return m.OldPhone(ctx)
	case roomdetail.FieldSleep:
		return m.OldSleep(ctx)
	case roomdetail.FieldBed:
		return m.OldBed(ctx)
	}
	return nil, fmt.Errorf("unknown Roomdetail field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomdetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomdetail.FieldRoomnumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomnumber(v)
		return nil
	case roomdetail.FieldRoomtypename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomtypename(v)
		return nil
	case roomdetail.FieldRoomprice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomprice(v)
		return nil
	case roomdetail.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case roomdetail.FieldSleep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSleep(v)
		return nil
	case roomdetail.FieldBed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBed(v)
		return nil
	}
	return fmt.Errorf("unknown Roomdetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomdetailMutation) AddedFields() []string {
	var fields []string
	if m.addroomprice != nil {
		fields = append(fields, roomdetail.FieldRoomprice)
	}
	if m.addsleep != nil {
		fields = append(fields, roomdetail.FieldSleep)
	}
	if m.addbed != nil {
		fields = append(fields, roomdetail.FieldBed)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomdetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case roomdetail.FieldRoomprice:
		return m.AddedRoomprice()
	case roomdetail.FieldSleep:
		return m.AddedSleep()
	case roomdetail.FieldBed:
		return m.AddedBed()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomdetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case roomdetail.FieldRoomprice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoomprice(v)
		return nil
	case roomdetail.FieldSleep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSleep(v)
		return nil
	case roomdetail.FieldBed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBed(v)
		return nil
	}
	return fmt.Errorf("unknown Roomdetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomdetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomdetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomdetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Roomdetail nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomdetailMutation) ResetField(name string) error {
	switch name {
	case roomdetail.FieldRoomnumber:
		m.ResetRoomnumber()
		return nil
	case roomdetail.FieldRoomtypename:
		m.ResetRoomtypename()
		return nil
	case roomdetail.FieldRoomprice:
		m.ResetRoomprice()
		return nil
	case roomdetail.FieldPhone:
		m.ResetPhone()
		return nil
	case roomdetail.FieldSleep:
		m.ResetSleep()
		return nil
	case roomdetail.FieldBed:
		m.ResetBed()
		return nil
	}
	return fmt.Errorf("unknown Roomdetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomdetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.pledge != nil {
		edges = append(edges, roomdetail.EdgePledge)
	}
	if m.petrule != nil {
		edges = append(edges, roomdetail.EdgePetrule)
	}
	if m.bedtype != nil {
		edges = append(edges, roomdetail.EdgeBedtype)
	}
	if m.employee != nil {
		edges = append(edges, roomdetail.EdgeEmployee)
	}
	if m.jobposition != nil {
		edges = append(edges, roomdetail.EdgeJobposition)
	}
	if m.staytype != nil {
		edges = append(edges, roomdetail.EdgeStaytype)
	}
	if m.roomdetails != nil {
		edges = append(edges, roomdetail.EdgeRoomdetails)
	}
	if m.cleaningrooms != nil {
		edges = append(edges, roomdetail.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomdetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roomdetail.EdgePledge:
		if id := m.pledge; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgePetrule:
		if id := m.petrule; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeBedtype:
		if id := m.bedtype; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeJobposition:
		if id := m.jobposition; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeStaytype:
		if id := m.staytype; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeRoomdetails:
		if id := m.roomdetails; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomdetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcleaningrooms != nil {
		edges = append(edges, roomdetail.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomdetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case roomdetail.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomdetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedpledge {
		edges = append(edges, roomdetail.EdgePledge)
	}
	if m.clearedpetrule {
		edges = append(edges, roomdetail.EdgePetrule)
	}
	if m.clearedbedtype {
		edges = append(edges, roomdetail.EdgeBedtype)
	}
	if m.clearedemployee {
		edges = append(edges, roomdetail.EdgeEmployee)
	}
	if m.clearedjobposition {
		edges = append(edges, roomdetail.EdgeJobposition)
	}
	if m.clearedstaytype {
		edges = append(edges, roomdetail.EdgeStaytype)
	}
	if m.clearedroomdetails {
		edges = append(edges, roomdetail.EdgeRoomdetails)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomdetailMutation) EdgeCleared(name string) bool {
	switch name {
	case roomdetail.EdgePledge:
		return m.clearedpledge
	case roomdetail.EdgePetrule:
		return m.clearedpetrule
	case roomdetail.EdgeBedtype:
		return m.clearedbedtype
	case roomdetail.EdgeEmployee:
		return m.clearedemployee
	case roomdetail.EdgeJobposition:
		return m.clearedjobposition
	case roomdetail.EdgeStaytype:
		return m.clearedstaytype
	case roomdetail.EdgeRoomdetails:
		return m.clearedroomdetails
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomdetailMutation) ClearEdge(name string) error {
	switch name {
	case roomdetail.EdgePledge:
		m.ClearPledge()
		return nil
	case roomdetail.EdgePetrule:
		m.ClearPetrule()
		return nil
	case roomdetail.EdgeBedtype:
		m.ClearBedtype()
		return nil
	case roomdetail.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case roomdetail.EdgeJobposition:
		m.ClearJobposition()
		return nil
	case roomdetail.EdgeStaytype:
		m.ClearStaytype()
		return nil
	case roomdetail.EdgeRoomdetails:
		m.ClearRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Roomdetail unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomdetailMutation) ResetEdge(name string) error {
	switch name {
	case roomdetail.EdgePledge:
		m.ResetPledge()
		return nil
	case roomdetail.EdgePetrule:
		m.ResetPetrule()
		return nil
	case roomdetail.EdgeBedtype:
		m.ResetBedtype()
		return nil
	case roomdetail.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case roomdetail.EdgeJobposition:
		m.ResetJobposition()
		return nil
	case roomdetail.EdgeStaytype:
		m.ResetStaytype()
		return nil
	case roomdetail.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	case roomdetail.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown Roomdetail edge %s", name)
}

// SituationMutation represents an operation that mutate the Situations
// nodes in the graph.
type SituationMutation struct {
	config
	op                Op
	typ               string
	id                *int
	situationname     *string
	clearedFields     map[string]struct{}
	situations        map[int]struct{}
	removedsituations map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Situation, error)
}

var _ ent.Mutation = (*SituationMutation)(nil)

// situationOption allows to manage the mutation configuration using functional options.
type situationOption func(*SituationMutation)

// newSituationMutation creates new mutation for $n.Name.
func newSituationMutation(c config, op Op, opts ...situationOption) *SituationMutation {
	m := &SituationMutation{
		config:        c,
		op:            op,
		typ:           TypeSituation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSituationID sets the id field of the mutation.
func withSituationID(id int) situationOption {
	return func(m *SituationMutation) {
		var (
			err   error
			once  sync.Once
			value *Situation
		)
		m.oldValue = func(ctx context.Context) (*Situation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Situation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSituation sets the old Situation of the mutation.
func withSituation(node *Situation) situationOption {
	return func(m *SituationMutation) {
		m.oldValue = func(context.Context) (*Situation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SituationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SituationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SituationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSituationname sets the situationname field.
func (m *SituationMutation) SetSituationname(s string) {
	m.situationname = &s
}

// Situationname returns the situationname value in the mutation.
func (m *SituationMutation) Situationname() (r string, exists bool) {
	v := m.situationname
	if v == nil {
		return
	}
	return *v, true
}

// OldSituationname returns the old situationname value of the Situation.
// If the Situation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SituationMutation) OldSituationname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSituationname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSituationname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSituationname: %w", err)
	}
	return oldValue.Situationname, nil
}

// ResetSituationname reset all changes of the "situationname" field.
func (m *SituationMutation) ResetSituationname() {
	m.situationname = nil
}

// AddSituationIDs adds the situations edge to Bill by ids.
func (m *SituationMutation) AddSituationIDs(ids ...int) {
	if m.situations == nil {
		m.situations = make(map[int]struct{})
	}
	for i := range ids {
		m.situations[ids[i]] = struct{}{}
	}
}

// RemoveSituationIDs removes the situations edge to Bill by ids.
func (m *SituationMutation) RemoveSituationIDs(ids ...int) {
	if m.removedsituations == nil {
		m.removedsituations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsituations[ids[i]] = struct{}{}
	}
}

// RemovedSituations returns the removed ids of situations.
func (m *SituationMutation) RemovedSituationsIDs() (ids []int) {
	for id := range m.removedsituations {
		ids = append(ids, id)
	}
	return
}

// SituationsIDs returns the situations ids in the mutation.
func (m *SituationMutation) SituationsIDs() (ids []int) {
	for id := range m.situations {
		ids = append(ids, id)
	}
	return
}

// ResetSituations reset all changes of the "situations" edge.
func (m *SituationMutation) ResetSituations() {
	m.situations = nil
	m.removedsituations = nil
}

// Op returns the operation name.
func (m *SituationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Situation).
func (m *SituationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SituationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.situationname != nil {
		fields = append(fields, situation.FieldSituationname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SituationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case situation.FieldSituationname:
		return m.Situationname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SituationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case situation.FieldSituationname:
		return m.OldSituationname(ctx)
	}
	return nil, fmt.Errorf("unknown Situation field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SituationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case situation.FieldSituationname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSituationname(v)
		return nil
	}
	return fmt.Errorf("unknown Situation field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SituationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SituationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SituationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Situation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SituationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SituationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SituationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Situation nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SituationMutation) ResetField(name string) error {
	switch name {
	case situation.FieldSituationname:
		m.ResetSituationname()
		return nil
	}
	return fmt.Errorf("unknown Situation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SituationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.situations != nil {
		edges = append(edges, situation.EdgeSituations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SituationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case situation.EdgeSituations:
		ids := make([]ent.Value, 0, len(m.situations))
		for id := range m.situations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SituationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsituations != nil {
		edges = append(edges, situation.EdgeSituations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SituationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case situation.EdgeSituations:
		ids := make([]ent.Value, 0, len(m.removedsituations))
		for id := range m.removedsituations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SituationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SituationMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SituationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Situation unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SituationMutation) ResetEdge(name string) error {
	switch name {
	case situation.EdgeSituations:
		m.ResetSituations()
		return nil
	}
	return fmt.Errorf("unknown Situation edge %s", name)
}

// StatusdMutation represents an operation that mutate the Statusds
// nodes in the graph.
type StatusdMutation struct {
	config
	op              Op
	typ             string
	id              *int
	statusdname     *string
	clearedFields   map[string]struct{}
	statusds        map[int]struct{}
	removedstatusds map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Statusd, error)
}

var _ ent.Mutation = (*StatusdMutation)(nil)

// statusdOption allows to manage the mutation configuration using functional options.
type statusdOption func(*StatusdMutation)

// newStatusdMutation creates new mutation for $n.Name.
func newStatusdMutation(c config, op Op, opts ...statusdOption) *StatusdMutation {
	m := &StatusdMutation{
		config:        c,
		op:            op,
		typ:           TypeStatusd,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusdID sets the id field of the mutation.
func withStatusdID(id int) statusdOption {
	return func(m *StatusdMutation) {
		var (
			err   error
			once  sync.Once
			value *Statusd
		)
		m.oldValue = func(ctx context.Context) (*Statusd, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statusd.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatusd sets the old Statusd of the mutation.
func withStatusd(node *Statusd) statusdOption {
	return func(m *StatusdMutation) {
		m.oldValue = func(context.Context) (*Statusd, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusdMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusdMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatusdMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatusdname sets the statusdname field.
func (m *StatusdMutation) SetStatusdname(s string) {
	m.statusdname = &s
}

// Statusdname returns the statusdname value in the mutation.
func (m *StatusdMutation) Statusdname() (r string, exists bool) {
	v := m.statusdname
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusdname returns the old statusdname value of the Statusd.
// If the Statusd object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusdMutation) OldStatusdname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusdname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusdname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusdname: %w", err)
	}
	return oldValue.Statusdname, nil
}

// ResetStatusdname reset all changes of the "statusdname" field.
func (m *StatusdMutation) ResetStatusdname() {
	m.statusdname = nil
}

// AddStatusdIDs adds the statusds edge to Deposit by ids.
func (m *StatusdMutation) AddStatusdIDs(ids ...int) {
	if m.statusds == nil {
		m.statusds = make(map[int]struct{})
	}
	for i := range ids {
		m.statusds[ids[i]] = struct{}{}
	}
}

// RemoveStatusdIDs removes the statusds edge to Deposit by ids.
func (m *StatusdMutation) RemoveStatusdIDs(ids ...int) {
	if m.removedstatusds == nil {
		m.removedstatusds = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatusds[ids[i]] = struct{}{}
	}
}

// RemovedStatusds returns the removed ids of statusds.
func (m *StatusdMutation) RemovedStatusdsIDs() (ids []int) {
	for id := range m.removedstatusds {
		ids = append(ids, id)
	}
	return
}

// StatusdsIDs returns the statusds ids in the mutation.
func (m *StatusdMutation) StatusdsIDs() (ids []int) {
	for id := range m.statusds {
		ids = append(ids, id)
	}
	return
}

// ResetStatusds reset all changes of the "statusds" edge.
func (m *StatusdMutation) ResetStatusds() {
	m.statusds = nil
	m.removedstatusds = nil
}

// Op returns the operation name.
func (m *StatusdMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statusd).
func (m *StatusdMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatusdMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.statusdname != nil {
		fields = append(fields, statusd.FieldStatusdname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatusdMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statusd.FieldStatusdname:
		return m.Statusdname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatusdMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statusd.FieldStatusdname:
		return m.OldStatusdname(ctx)
	}
	return nil, fmt.Errorf("unknown Statusd field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusdMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statusd.FieldStatusdname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusdname(v)
		return nil
	}
	return fmt.Errorf("unknown Statusd field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatusdMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatusdMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusdMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statusd numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatusdMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatusdMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusdMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statusd nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatusdMutation) ResetField(name string) error {
	switch name {
	case statusd.FieldStatusdname:
		m.ResetStatusdname()
		return nil
	}
	return fmt.Errorf("unknown Statusd field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatusdMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.statusds != nil {
		edges = append(edges, statusd.EdgeStatusds)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatusdMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statusd.EdgeStatusds:
		ids := make([]ent.Value, 0, len(m.statusds))
		for id := range m.statusds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatusdMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatusds != nil {
		edges = append(edges, statusd.EdgeStatusds)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatusdMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statusd.EdgeStatusds:
		ids := make([]ent.Value, 0, len(m.removedstatusds))
		for id := range m.removedstatusds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatusdMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatusdMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatusdMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statusd unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatusdMutation) ResetEdge(name string) error {
	switch name {
	case statusd.EdgeStatusds:
		m.ResetStatusds()
		return nil
	}
	return fmt.Errorf("unknown Statusd edge %s", name)
}

// StaytypeMutation represents an operation that mutate the Staytypes
// nodes in the graph.
type StaytypeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	staytype           *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Staytype, error)
}

var _ ent.Mutation = (*StaytypeMutation)(nil)

// staytypeOption allows to manage the mutation configuration using functional options.
type staytypeOption func(*StaytypeMutation)

// newStaytypeMutation creates new mutation for $n.Name.
func newStaytypeMutation(c config, op Op, opts ...staytypeOption) *StaytypeMutation {
	m := &StaytypeMutation{
		config:        c,
		op:            op,
		typ:           TypeStaytype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaytypeID sets the id field of the mutation.
func withStaytypeID(id int) staytypeOption {
	return func(m *StaytypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Staytype
		)
		m.oldValue = func(ctx context.Context) (*Staytype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staytype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaytype sets the old Staytype of the mutation.
func withStaytype(node *Staytype) staytypeOption {
	return func(m *StaytypeMutation) {
		m.oldValue = func(context.Context) (*Staytype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaytypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaytypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StaytypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStaytype sets the staytype field.
func (m *StaytypeMutation) SetStaytype(s string) {
	m.staytype = &s
}

// Staytype returns the staytype value in the mutation.
func (m *StaytypeMutation) Staytype() (r string, exists bool) {
	v := m.staytype
	if v == nil {
		return
	}
	return *v, true
}

// OldStaytype returns the old staytype value of the Staytype.
// If the Staytype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StaytypeMutation) OldStaytype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStaytype is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStaytype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaytype: %w", err)
	}
	return oldValue.Staytype, nil
}

// ResetStaytype reset all changes of the "staytype" field.
func (m *StaytypeMutation) ResetStaytype() {
	m.staytype = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *StaytypeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *StaytypeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *StaytypeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *StaytypeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *StaytypeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *StaytypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Staytype).
func (m *StaytypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StaytypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.staytype != nil {
		fields = append(fields, staytype.FieldStaytype)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StaytypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staytype.FieldStaytype:
		return m.Staytype()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StaytypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staytype.FieldStaytype:
		return m.OldStaytype(ctx)
	}
	return nil, fmt.Errorf("unknown Staytype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StaytypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staytype.FieldStaytype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaytype(v)
		return nil
	}
	return fmt.Errorf("unknown Staytype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StaytypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StaytypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StaytypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Staytype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StaytypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StaytypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaytypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Staytype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StaytypeMutation) ResetField(name string) error {
	switch name {
	case staytype.FieldStaytype:
		m.ResetStaytype()
		return nil
	}
	return fmt.Errorf("unknown Staytype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StaytypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, staytype.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StaytypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staytype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StaytypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, staytype.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StaytypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case staytype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StaytypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StaytypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StaytypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Staytype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StaytypeMutation) ResetEdge(name string) error {
	switch name {
	case staytype.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Staytype edge %s", name)
}

// WifiMutation represents an operation that mutate the Wifis
// nodes in the graph.
type WifiMutation struct {
	config
	op            Op
	typ           string
	id            *int
	wifiname      *string
	clearedFields map[string]struct{}
	wifis         map[int]struct{}
	removedwifis  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Wifi, error)
}

var _ ent.Mutation = (*WifiMutation)(nil)

// wifiOption allows to manage the mutation configuration using functional options.
type wifiOption func(*WifiMutation)

// newWifiMutation creates new mutation for $n.Name.
func newWifiMutation(c config, op Op, opts ...wifiOption) *WifiMutation {
	m := &WifiMutation{
		config:        c,
		op:            op,
		typ:           TypeWifi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWifiID sets the id field of the mutation.
func withWifiID(id int) wifiOption {
	return func(m *WifiMutation) {
		var (
			err   error
			once  sync.Once
			value *Wifi
		)
		m.oldValue = func(ctx context.Context) (*Wifi, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wifi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWifi sets the old Wifi of the mutation.
func withWifi(node *Wifi) wifiOption {
	return func(m *WifiMutation) {
		m.oldValue = func(context.Context) (*Wifi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WifiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WifiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WifiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWifiname sets the wifiname field.
func (m *WifiMutation) SetWifiname(s string) {
	m.wifiname = &s
}

// Wifiname returns the wifiname value in the mutation.
func (m *WifiMutation) Wifiname() (r string, exists bool) {
	v := m.wifiname
	if v == nil {
		return
	}
	return *v, true
}

// OldWifiname returns the old wifiname value of the Wifi.
// If the Wifi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WifiMutation) OldWifiname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWifiname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWifiname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWifiname: %w", err)
	}
	return oldValue.Wifiname, nil
}

// ResetWifiname reset all changes of the "wifiname" field.
func (m *WifiMutation) ResetWifiname() {
	m.wifiname = nil
}

// AddWifiIDs adds the wifis edge to Lease by ids.
func (m *WifiMutation) AddWifiIDs(ids ...int) {
	if m.wifis == nil {
		m.wifis = make(map[int]struct{})
	}
	for i := range ids {
		m.wifis[ids[i]] = struct{}{}
	}
}

// RemoveWifiIDs removes the wifis edge to Lease by ids.
func (m *WifiMutation) RemoveWifiIDs(ids ...int) {
	if m.removedwifis == nil {
		m.removedwifis = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwifis[ids[i]] = struct{}{}
	}
}

// RemovedWifis returns the removed ids of wifis.
func (m *WifiMutation) RemovedWifisIDs() (ids []int) {
	for id := range m.removedwifis {
		ids = append(ids, id)
	}
	return
}

// WifisIDs returns the wifis ids in the mutation.
func (m *WifiMutation) WifisIDs() (ids []int) {
	for id := range m.wifis {
		ids = append(ids, id)
	}
	return
}

// ResetWifis reset all changes of the "wifis" edge.
func (m *WifiMutation) ResetWifis() {
	m.wifis = nil
	m.removedwifis = nil
}

// Op returns the operation name.
func (m *WifiMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Wifi).
func (m *WifiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WifiMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.wifiname != nil {
		fields = append(fields, wifi.FieldWifiname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WifiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wifi.FieldWifiname:
		return m.Wifiname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WifiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wifi.FieldWifiname:
		return m.OldWifiname(ctx)
	}
	return nil, fmt.Errorf("unknown Wifi field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WifiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wifi.FieldWifiname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWifiname(v)
		return nil
	}
	return fmt.Errorf("unknown Wifi field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WifiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WifiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WifiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Wifi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WifiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WifiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WifiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wifi nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WifiMutation) ResetField(name string) error {
	switch name {
	case wifi.FieldWifiname:
		m.ResetWifiname()
		return nil
	}
	return fmt.Errorf("unknown Wifi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WifiMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.wifis != nil {
		edges = append(edges, wifi.EdgeWifis)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WifiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wifi.EdgeWifis:
		ids := make([]ent.Value, 0, len(m.wifis))
		for id := range m.wifis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WifiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedwifis != nil {
		edges = append(edges, wifi.EdgeWifis)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WifiMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wifi.EdgeWifis:
		ids := make([]ent.Value, 0, len(m.removedwifis))
		for id := range m.removedwifis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WifiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WifiMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WifiMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Wifi unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WifiMutation) ResetEdge(name string) error {
	switch name {
	case wifi.EdgeWifis:
		m.ResetWifis()
		return nil
	}
	return fmt.Errorf("unknown Wifi edge %s", name)
}
