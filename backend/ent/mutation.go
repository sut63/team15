// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team15/app/ent/bedtype"
	"github.com/team15/app/ent/bill"
	"github.com/team15/app/ent/cleanername"
	"github.com/team15/app/ent/cleaningroom"
	"github.com/team15/app/ent/deposit"
	"github.com/team15/app/ent/employee"
	"github.com/team15/app/ent/jobposition"
	"github.com/team15/app/ent/lease"
	"github.com/team15/app/ent/lengthtime"
	"github.com/team15/app/ent/payment"
	"github.com/team15/app/ent/petrule"
	"github.com/team15/app/ent/pledge"
	"github.com/team15/app/ent/rentalstatus"
	"github.com/team15/app/ent/repairinvoice"
	"github.com/team15/app/ent/roomdetail"
	"github.com/team15/app/ent/situation"
	"github.com/team15/app/ent/statusd"
	"github.com/team15/app/ent/staytype"
	"github.com/team15/app/ent/wifi"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBedtype       = "Bedtype"
	TypeBill          = "Bill"
	TypeCleanerName   = "CleanerName"
	TypeCleaningRoom  = "CleaningRoom"
	TypeDeposit       = "Deposit"
	TypeEmployee      = "Employee"
	TypeJobposition   = "Jobposition"
	TypeLease         = "Lease"
	TypeLengthTime    = "LengthTime"
	TypePayment       = "Payment"
	TypePetrule       = "Petrule"
	TypePledge        = "Pledge"
	TypeRentalstatus  = "Rentalstatus"
	TypeRepairinvoice = "Repairinvoice"
	TypeRoomdetail    = "Roomdetail"
	TypeSituation     = "Situation"
	TypeStatusd       = "Statusd"
	TypeStaytype      = "Staytype"
	TypeWifi          = "Wifi"
)

// BedtypeMutation represents an operation that mutate the Bedtypes
// nodes in the graph.
type BedtypeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	bedtypename        *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Bedtype, error)
}

var _ ent.Mutation = (*BedtypeMutation)(nil)

// bedtypeOption allows to manage the mutation configuration using functional options.
type bedtypeOption func(*BedtypeMutation)

// newBedtypeMutation creates new mutation for $n.Name.
func newBedtypeMutation(c config, op Op, opts ...bedtypeOption) *BedtypeMutation {
	m := &BedtypeMutation{
		config:        c,
		op:            op,
		typ:           TypeBedtype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBedtypeID sets the id field of the mutation.
func withBedtypeID(id int) bedtypeOption {
	return func(m *BedtypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Bedtype
		)
		m.oldValue = func(ctx context.Context) (*Bedtype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bedtype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBedtype sets the old Bedtype of the mutation.
func withBedtype(node *Bedtype) bedtypeOption {
	return func(m *BedtypeMutation) {
		m.oldValue = func(context.Context) (*Bedtype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BedtypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BedtypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BedtypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBedtypename sets the bedtypename field.
func (m *BedtypeMutation) SetBedtypename(s string) {
	m.bedtypename = &s
}

// Bedtypename returns the bedtypename value in the mutation.
func (m *BedtypeMutation) Bedtypename() (r string, exists bool) {
	v := m.bedtypename
	if v == nil {
		return
	}
	return *v, true
}

// OldBedtypename returns the old bedtypename value of the Bedtype.
// If the Bedtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BedtypeMutation) OldBedtypename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBedtypename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBedtypename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBedtypename: %w", err)
	}
	return oldValue.Bedtypename, nil
}

// ResetBedtypename reset all changes of the "bedtypename" field.
func (m *BedtypeMutation) ResetBedtypename() {
	m.bedtypename = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *BedtypeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *BedtypeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *BedtypeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *BedtypeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *BedtypeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *BedtypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bedtype).
func (m *BedtypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BedtypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.bedtypename != nil {
		fields = append(fields, bedtype.FieldBedtypename)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BedtypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bedtype.FieldBedtypename:
		return m.Bedtypename()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BedtypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bedtype.FieldBedtypename:
		return m.OldBedtypename(ctx)
	}
	return nil, fmt.Errorf("unknown Bedtype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BedtypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bedtype.FieldBedtypename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBedtypename(v)
		return nil
	}
	return fmt.Errorf("unknown Bedtype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BedtypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BedtypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BedtypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bedtype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BedtypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BedtypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BedtypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bedtype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BedtypeMutation) ResetField(name string) error {
	switch name {
	case bedtype.FieldBedtypename:
		m.ResetBedtypename()
		return nil
	}
	return fmt.Errorf("unknown Bedtype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BedtypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, bedtype.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BedtypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bedtype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BedtypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, bedtype.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BedtypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bedtype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BedtypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BedtypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BedtypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bedtype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BedtypeMutation) ResetEdge(name string) error {
	switch name {
	case bedtype.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Bedtype edge %s", name)
}

// BillMutation represents an operation that mutate the Bills
// nodes in the graph.
type BillMutation struct {
	config
	op                Op
	typ               string
	id                *int
	addedtime         *time.Time
	total             *int
	addtotal          *int
	clearedFields     map[string]struct{}
	_Situation        *int
	cleared_Situation bool
	_Payment          *int
	cleared_Payment   bool
	done              bool
	oldValue          func(context.Context) (*Bill, error)
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows to manage the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for $n.Name.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the id field of the mutation.
func withBillID(id int) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *BillMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *BillMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *BillMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetTotal sets the total field.
func (m *BillMutation) SetTotal(i int) {
	m.total = &i
	m.addtotal = nil
}

// Total returns the total value in the mutation.
func (m *BillMutation) Total() (r int, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old total value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds i to total.
func (m *BillMutation) AddTotal(i int) {
	if m.addtotal != nil {
		*m.addtotal += i
	} else {
		m.addtotal = &i
	}
}

// AddedTotal returns the value that was added to the total field in this mutation.
func (m *BillMutation) AddedTotal() (r int, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal reset all changes of the "total" field.
func (m *BillMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetSituationID sets the Situation edge to Situation by id.
func (m *BillMutation) SetSituationID(id int) {
	m._Situation = &id
}

// ClearSituation clears the Situation edge to Situation.
func (m *BillMutation) ClearSituation() {
	m.cleared_Situation = true
}

// SituationCleared returns if the edge Situation was cleared.
func (m *BillMutation) SituationCleared() bool {
	return m.cleared_Situation
}

// SituationID returns the Situation id in the mutation.
func (m *BillMutation) SituationID() (id int, exists bool) {
	if m._Situation != nil {
		return *m._Situation, true
	}
	return
}

// SituationIDs returns the Situation ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SituationID instead. It exists only for internal usage by the builders.
func (m *BillMutation) SituationIDs() (ids []int) {
	if id := m._Situation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSituation reset all changes of the "Situation" edge.
func (m *BillMutation) ResetSituation() {
	m._Situation = nil
	m.cleared_Situation = false
}

// SetPaymentID sets the Payment edge to Payment by id.
func (m *BillMutation) SetPaymentID(id int) {
	m._Payment = &id
}

// ClearPayment clears the Payment edge to Payment.
func (m *BillMutation) ClearPayment() {
	m.cleared_Payment = true
}

// PaymentCleared returns if the edge Payment was cleared.
func (m *BillMutation) PaymentCleared() bool {
	return m.cleared_Payment
}

// PaymentID returns the Payment id in the mutation.
func (m *BillMutation) PaymentID() (id int, exists bool) {
	if m._Payment != nil {
		return *m._Payment, true
	}
	return
}

// PaymentIDs returns the Payment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PaymentID instead. It exists only for internal usage by the builders.
func (m *BillMutation) PaymentIDs() (ids []int) {
	if id := m._Payment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayment reset all changes of the "Payment" edge.
func (m *BillMutation) ResetPayment() {
	m._Payment = nil
	m.cleared_Payment = false
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.addedtime != nil {
		fields = append(fields, bill.FieldAddedtime)
	}
	if m.total != nil {
		fields = append(fields, bill.FieldTotal)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldAddedtime:
		return m.Addedtime()
	case bill.FieldTotal:
		return m.Total()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldAddedtime:
		return m.OldAddedtime(ctx)
	case bill.FieldTotal:
		return m.OldTotal(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	case bill.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillMutation) AddedFields() []string {
	var fields []string
	if m.addtotal != nil {
		fields = append(fields, bill.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bill.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	case bill.FieldTotal:
		m.ResetTotal()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Situation != nil {
		edges = append(edges, bill.EdgeSituation)
	}
	if m._Payment != nil {
		edges = append(edges, bill.EdgePayment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgeSituation:
		if id := m._Situation; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgePayment:
		if id := m._Payment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Situation {
		edges = append(edges, bill.EdgeSituation)
	}
	if m.cleared_Payment {
		edges = append(edges, bill.EdgePayment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgeSituation:
		return m.cleared_Situation
	case bill.EdgePayment:
		return m.cleared_Payment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgeSituation:
		m.ClearSituation()
		return nil
	case bill.EdgePayment:
		m.ClearPayment()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgeSituation:
		m.ResetSituation()
		return nil
	case bill.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// CleanerNameMutation represents an operation that mutate the CleanerNames
// nodes in the graph.
type CleanerNameMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	cleanername          *string
	clearedFields        map[string]struct{}
	cleaningrooms        map[int]struct{}
	removedcleaningrooms map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*CleanerName, error)
}

var _ ent.Mutation = (*CleanerNameMutation)(nil)

// cleanernameOption allows to manage the mutation configuration using functional options.
type cleanernameOption func(*CleanerNameMutation)

// newCleanerNameMutation creates new mutation for $n.Name.
func newCleanerNameMutation(c config, op Op, opts ...cleanernameOption) *CleanerNameMutation {
	m := &CleanerNameMutation{
		config:        c,
		op:            op,
		typ:           TypeCleanerName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCleanerNameID sets the id field of the mutation.
func withCleanerNameID(id int) cleanernameOption {
	return func(m *CleanerNameMutation) {
		var (
			err   error
			once  sync.Once
			value *CleanerName
		)
		m.oldValue = func(ctx context.Context) (*CleanerName, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CleanerName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCleanerName sets the old CleanerName of the mutation.
func withCleanerName(node *CleanerName) cleanernameOption {
	return func(m *CleanerNameMutation) {
		m.oldValue = func(context.Context) (*CleanerName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CleanerNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CleanerNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CleanerNameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCleanername sets the cleanername field.
func (m *CleanerNameMutation) SetCleanername(s string) {
	m.cleanername = &s
}

// Cleanername returns the cleanername value in the mutation.
func (m *CleanerNameMutation) Cleanername() (r string, exists bool) {
	v := m.cleanername
	if v == nil {
		return
	}
	return *v, true
}

// OldCleanername returns the old cleanername value of the CleanerName.
// If the CleanerName object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleanerNameMutation) OldCleanername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCleanername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCleanername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCleanername: %w", err)
	}
	return oldValue.Cleanername, nil
}

// ResetCleanername reset all changes of the "cleanername" field.
func (m *CleanerNameMutation) ResetCleanername() {
	m.cleanername = nil
}

// AddCleaningroomIDs adds the cleaningrooms edge to CleaningRoom by ids.
func (m *CleanerNameMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to CleaningRoom by ids.
func (m *CleanerNameMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *CleanerNameMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *CleanerNameMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *CleanerNameMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *CleanerNameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CleanerName).
func (m *CleanerNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CleanerNameMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.cleanername != nil {
		fields = append(fields, cleanername.FieldCleanername)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CleanerNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cleanername.FieldCleanername:
		return m.Cleanername()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CleanerNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cleanername.FieldCleanername:
		return m.OldCleanername(ctx)
	}
	return nil, fmt.Errorf("unknown CleanerName field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleanerNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cleanername.FieldCleanername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCleanername(v)
		return nil
	}
	return fmt.Errorf("unknown CleanerName field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CleanerNameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CleanerNameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleanerNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CleanerName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CleanerNameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CleanerNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CleanerNameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CleanerName nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CleanerNameMutation) ResetField(name string) error {
	switch name {
	case cleanername.FieldCleanername:
		m.ResetCleanername()
		return nil
	}
	return fmt.Errorf("unknown CleanerName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CleanerNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleaningrooms != nil {
		edges = append(edges, cleanername.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CleanerNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cleanername.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CleanerNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcleaningrooms != nil {
		edges = append(edges, cleanername.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CleanerNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cleanername.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CleanerNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CleanerNameMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CleanerNameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CleanerName unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CleanerNameMutation) ResetEdge(name string) error {
	switch name {
	case cleanername.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown CleanerName edge %s", name)
}

// CleaningRoomMutation represents an operation that mutate the CleaningRooms
// nodes in the graph.
type CleaningRoomMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	dateandstarttime    *time.Time
	note                *string
	clearedFields       map[string]struct{}
	roomdetail          *int
	clearedroomdetail   bool
	_CleanerName        *int
	cleared_CleanerName bool
	_LengthTime         *int
	cleared_LengthTime  bool
	_Employee           *int
	cleared_Employee    bool
	done                bool
	oldValue            func(context.Context) (*CleaningRoom, error)
}

var _ ent.Mutation = (*CleaningRoomMutation)(nil)

// cleaningroomOption allows to manage the mutation configuration using functional options.
type cleaningroomOption func(*CleaningRoomMutation)

// newCleaningRoomMutation creates new mutation for $n.Name.
func newCleaningRoomMutation(c config, op Op, opts ...cleaningroomOption) *CleaningRoomMutation {
	m := &CleaningRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeCleaningRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCleaningRoomID sets the id field of the mutation.
func withCleaningRoomID(id int) cleaningroomOption {
	return func(m *CleaningRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *CleaningRoom
		)
		m.oldValue = func(ctx context.Context) (*CleaningRoom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CleaningRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCleaningRoom sets the old CleaningRoom of the mutation.
func withCleaningRoom(node *CleaningRoom) cleaningroomOption {
	return func(m *CleaningRoomMutation) {
		m.oldValue = func(context.Context) (*CleaningRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CleaningRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CleaningRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CleaningRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDateandstarttime sets the dateandstarttime field.
func (m *CleaningRoomMutation) SetDateandstarttime(t time.Time) {
	m.dateandstarttime = &t
}

// Dateandstarttime returns the dateandstarttime value in the mutation.
func (m *CleaningRoomMutation) Dateandstarttime() (r time.Time, exists bool) {
	v := m.dateandstarttime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateandstarttime returns the old dateandstarttime value of the CleaningRoom.
// If the CleaningRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleaningRoomMutation) OldDateandstarttime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateandstarttime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateandstarttime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateandstarttime: %w", err)
	}
	return oldValue.Dateandstarttime, nil
}

// ResetDateandstarttime reset all changes of the "dateandstarttime" field.
func (m *CleaningRoomMutation) ResetDateandstarttime() {
	m.dateandstarttime = nil
}

// SetNote sets the note field.
func (m *CleaningRoomMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the note value in the mutation.
func (m *CleaningRoomMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old note value of the CleaningRoom.
// If the CleaningRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CleaningRoomMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote reset all changes of the "note" field.
func (m *CleaningRoomMutation) ResetNote() {
	m.note = nil
}

// SetRoomdetailID sets the roomdetail edge to Roomdetail by id.
func (m *CleaningRoomMutation) SetRoomdetailID(id int) {
	m.roomdetail = &id
}

// ClearRoomdetail clears the roomdetail edge to Roomdetail.
func (m *CleaningRoomMutation) ClearRoomdetail() {
	m.clearedroomdetail = true
}

// RoomdetailCleared returns if the edge roomdetail was cleared.
func (m *CleaningRoomMutation) RoomdetailCleared() bool {
	return m.clearedroomdetail
}

// RoomdetailID returns the roomdetail id in the mutation.
func (m *CleaningRoomMutation) RoomdetailID() (id int, exists bool) {
	if m.roomdetail != nil {
		return *m.roomdetail, true
	}
	return
}

// RoomdetailIDs returns the roomdetail ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomdetailID instead. It exists only for internal usage by the builders.
func (m *CleaningRoomMutation) RoomdetailIDs() (ids []int) {
	if id := m.roomdetail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomdetail reset all changes of the "roomdetail" edge.
func (m *CleaningRoomMutation) ResetRoomdetail() {
	m.roomdetail = nil
	m.clearedroomdetail = false
}

// SetCleanerNameID sets the CleanerName edge to CleanerName by id.
func (m *CleaningRoomMutation) SetCleanerNameID(id int) {
	m._CleanerName = &id
}

// ClearCleanerName clears the CleanerName edge to CleanerName.
func (m *CleaningRoomMutation) ClearCleanerName() {
	m.cleared_CleanerName = true
}

// CleanerNameCleared returns if the edge CleanerName was cleared.
func (m *CleaningRoomMutation) CleanerNameCleared() bool {
	return m.cleared_CleanerName
}

// CleanerNameID returns the CleanerName id in the mutation.
func (m *CleaningRoomMutation) CleanerNameID() (id int, exists bool) {
	if m._CleanerName != nil {
		return *m._CleanerName, true
	}
	return
}

// CleanerNameIDs returns the CleanerName ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CleanerNameID instead. It exists only for internal usage by the builders.
func (m *CleaningRoomMutation) CleanerNameIDs() (ids []int) {
	if id := m._CleanerName; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCleanerName reset all changes of the "CleanerName" edge.
func (m *CleaningRoomMutation) ResetCleanerName() {
	m._CleanerName = nil
	m.cleared_CleanerName = false
}

// SetLengthTimeID sets the LengthTime edge to LengthTime by id.
func (m *CleaningRoomMutation) SetLengthTimeID(id int) {
	m._LengthTime = &id
}

// ClearLengthTime clears the LengthTime edge to LengthTime.
func (m *CleaningRoomMutation) ClearLengthTime() {
	m.cleared_LengthTime = true
}

// LengthTimeCleared returns if the edge LengthTime was cleared.
func (m *CleaningRoomMutation) LengthTimeCleared() bool {
	return m.cleared_LengthTime
}

// LengthTimeID returns the LengthTime id in the mutation.
func (m *CleaningRoomMutation) LengthTimeID() (id int, exists bool) {
	if m._LengthTime != nil {
		return *m._LengthTime, true
	}
	return
}

// LengthTimeIDs returns the LengthTime ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LengthTimeID instead. It exists only for internal usage by the builders.
func (m *CleaningRoomMutation) LengthTimeIDs() (ids []int) {
	if id := m._LengthTime; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLengthTime reset all changes of the "LengthTime" edge.
func (m *CleaningRoomMutation) ResetLengthTime() {
	m._LengthTime = nil
	m.cleared_LengthTime = false
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *CleaningRoomMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *CleaningRoomMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *CleaningRoomMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *CleaningRoomMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *CleaningRoomMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *CleaningRoomMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// Op returns the operation name.
func (m *CleaningRoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CleaningRoom).
func (m *CleaningRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CleaningRoomMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.dateandstarttime != nil {
		fields = append(fields, cleaningroom.FieldDateandstarttime)
	}
	if m.note != nil {
		fields = append(fields, cleaningroom.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CleaningRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cleaningroom.FieldDateandstarttime:
		return m.Dateandstarttime()
	case cleaningroom.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CleaningRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cleaningroom.FieldDateandstarttime:
		return m.OldDateandstarttime(ctx)
	case cleaningroom.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown CleaningRoom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleaningRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cleaningroom.FieldDateandstarttime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateandstarttime(v)
		return nil
	case cleaningroom.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown CleaningRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CleaningRoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CleaningRoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CleaningRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CleaningRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CleaningRoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CleaningRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CleaningRoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CleaningRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CleaningRoomMutation) ResetField(name string) error {
	switch name {
	case cleaningroom.FieldDateandstarttime:
		m.ResetDateandstarttime()
		return nil
	case cleaningroom.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown CleaningRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CleaningRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roomdetail != nil {
		edges = append(edges, cleaningroom.EdgeRoomdetail)
	}
	if m._CleanerName != nil {
		edges = append(edges, cleaningroom.EdgeCleanerName)
	}
	if m._LengthTime != nil {
		edges = append(edges, cleaningroom.EdgeLengthTime)
	}
	if m._Employee != nil {
		edges = append(edges, cleaningroom.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CleaningRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cleaningroom.EdgeRoomdetail:
		if id := m.roomdetail; id != nil {
			return []ent.Value{*id}
		}
	case cleaningroom.EdgeCleanerName:
		if id := m._CleanerName; id != nil {
			return []ent.Value{*id}
		}
	case cleaningroom.EdgeLengthTime:
		if id := m._LengthTime; id != nil {
			return []ent.Value{*id}
		}
	case cleaningroom.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CleaningRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CleaningRoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CleaningRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroomdetail {
		edges = append(edges, cleaningroom.EdgeRoomdetail)
	}
	if m.cleared_CleanerName {
		edges = append(edges, cleaningroom.EdgeCleanerName)
	}
	if m.cleared_LengthTime {
		edges = append(edges, cleaningroom.EdgeLengthTime)
	}
	if m.cleared_Employee {
		edges = append(edges, cleaningroom.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CleaningRoomMutation) EdgeCleared(name string) bool {
	switch name {
	case cleaningroom.EdgeRoomdetail:
		return m.clearedroomdetail
	case cleaningroom.EdgeCleanerName:
		return m.cleared_CleanerName
	case cleaningroom.EdgeLengthTime:
		return m.cleared_LengthTime
	case cleaningroom.EdgeEmployee:
		return m.cleared_Employee
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CleaningRoomMutation) ClearEdge(name string) error {
	switch name {
	case cleaningroom.EdgeRoomdetail:
		m.ClearRoomdetail()
		return nil
	case cleaningroom.EdgeCleanerName:
		m.ClearCleanerName()
		return nil
	case cleaningroom.EdgeLengthTime:
		m.ClearLengthTime()
		return nil
	case cleaningroom.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown CleaningRoom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CleaningRoomMutation) ResetEdge(name string) error {
	switch name {
	case cleaningroom.EdgeRoomdetail:
		m.ResetRoomdetail()
		return nil
	case cleaningroom.EdgeCleanerName:
		m.ResetCleanerName()
		return nil
	case cleaningroom.EdgeLengthTime:
		m.ResetLengthTime()
		return nil
	case cleaningroom.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown CleaningRoom edge %s", name)
}

// DepositMutation represents an operation that mutate the Deposits
// nodes in the graph.
type DepositMutation struct {
	config
	op               Op
	typ              string
	id               *int
	addedtime        *time.Time
	info             *string
	clearedFields    map[string]struct{}
	_Employee        *int
	cleared_Employee bool
	_Statusd         *int
	cleared_Statusd  bool
	_Lease           *int
	cleared_Lease    bool
	done             bool
	oldValue         func(context.Context) (*Deposit, error)
}

var _ ent.Mutation = (*DepositMutation)(nil)

// depositOption allows to manage the mutation configuration using functional options.
type depositOption func(*DepositMutation)

// newDepositMutation creates new mutation for $n.Name.
func newDepositMutation(c config, op Op, opts ...depositOption) *DepositMutation {
	m := &DepositMutation{
		config:        c,
		op:            op,
		typ:           TypeDeposit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepositID sets the id field of the mutation.
func withDepositID(id int) depositOption {
	return func(m *DepositMutation) {
		var (
			err   error
			once  sync.Once
			value *Deposit
		)
		m.oldValue = func(ctx context.Context) (*Deposit, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deposit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeposit sets the old Deposit of the mutation.
func withDeposit(node *Deposit) depositOption {
	return func(m *DepositMutation) {
		m.oldValue = func(context.Context) (*Deposit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepositMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepositMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepositMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *DepositMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *DepositMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *DepositMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetInfo sets the info field.
func (m *DepositMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the info value in the mutation.
func (m *DepositMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old info value of the Deposit.
// If the Deposit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepositMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo reset all changes of the "info" field.
func (m *DepositMutation) ResetInfo() {
	m.info = nil
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *DepositMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *DepositMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *DepositMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *DepositMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *DepositMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *DepositMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// SetStatusdID sets the Statusd edge to Statusd by id.
func (m *DepositMutation) SetStatusdID(id int) {
	m._Statusd = &id
}

// ClearStatusd clears the Statusd edge to Statusd.
func (m *DepositMutation) ClearStatusd() {
	m.cleared_Statusd = true
}

// StatusdCleared returns if the edge Statusd was cleared.
func (m *DepositMutation) StatusdCleared() bool {
	return m.cleared_Statusd
}

// StatusdID returns the Statusd id in the mutation.
func (m *DepositMutation) StatusdID() (id int, exists bool) {
	if m._Statusd != nil {
		return *m._Statusd, true
	}
	return
}

// StatusdIDs returns the Statusd ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatusdID instead. It exists only for internal usage by the builders.
func (m *DepositMutation) StatusdIDs() (ids []int) {
	if id := m._Statusd; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusd reset all changes of the "Statusd" edge.
func (m *DepositMutation) ResetStatusd() {
	m._Statusd = nil
	m.cleared_Statusd = false
}

// SetLeaseID sets the Lease edge to Lease by id.
func (m *DepositMutation) SetLeaseID(id int) {
	m._Lease = &id
}

// ClearLease clears the Lease edge to Lease.
func (m *DepositMutation) ClearLease() {
	m.cleared_Lease = true
}

// LeaseCleared returns if the edge Lease was cleared.
func (m *DepositMutation) LeaseCleared() bool {
	return m.cleared_Lease
}

// LeaseID returns the Lease id in the mutation.
func (m *DepositMutation) LeaseID() (id int, exists bool) {
	if m._Lease != nil {
		return *m._Lease, true
	}
	return
}

// LeaseIDs returns the Lease ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LeaseID instead. It exists only for internal usage by the builders.
func (m *DepositMutation) LeaseIDs() (ids []int) {
	if id := m._Lease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLease reset all changes of the "Lease" edge.
func (m *DepositMutation) ResetLease() {
	m._Lease = nil
	m.cleared_Lease = false
}

// Op returns the operation name.
func (m *DepositMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Deposit).
func (m *DepositMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepositMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.addedtime != nil {
		fields = append(fields, deposit.FieldAddedtime)
	}
	if m.info != nil {
		fields = append(fields, deposit.FieldInfo)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepositMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deposit.FieldAddedtime:
		return m.Addedtime()
	case deposit.FieldInfo:
		return m.Info()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepositMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deposit.FieldAddedtime:
		return m.OldAddedtime(ctx)
	case deposit.FieldInfo:
		return m.OldInfo(ctx)
	}
	return nil, fmt.Errorf("unknown Deposit field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepositMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deposit.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	case deposit.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	}
	return fmt.Errorf("unknown Deposit field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepositMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepositMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepositMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deposit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepositMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepositMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepositMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Deposit nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepositMutation) ResetField(name string) error {
	switch name {
	case deposit.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	case deposit.FieldInfo:
		m.ResetInfo()
		return nil
	}
	return fmt.Errorf("unknown Deposit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepositMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Employee != nil {
		edges = append(edges, deposit.EdgeEmployee)
	}
	if m._Statusd != nil {
		edges = append(edges, deposit.EdgeStatusd)
	}
	if m._Lease != nil {
		edges = append(edges, deposit.EdgeLease)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepositMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deposit.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	case deposit.EdgeStatusd:
		if id := m._Statusd; id != nil {
			return []ent.Value{*id}
		}
	case deposit.EdgeLease:
		if id := m._Lease; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepositMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepositMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepositMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Employee {
		edges = append(edges, deposit.EdgeEmployee)
	}
	if m.cleared_Statusd {
		edges = append(edges, deposit.EdgeStatusd)
	}
	if m.cleared_Lease {
		edges = append(edges, deposit.EdgeLease)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepositMutation) EdgeCleared(name string) bool {
	switch name {
	case deposit.EdgeEmployee:
		return m.cleared_Employee
	case deposit.EdgeStatusd:
		return m.cleared_Statusd
	case deposit.EdgeLease:
		return m.cleared_Lease
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepositMutation) ClearEdge(name string) error {
	switch name {
	case deposit.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case deposit.EdgeStatusd:
		m.ClearStatusd()
		return nil
	case deposit.EdgeLease:
		m.ClearLease()
		return nil
	}
	return fmt.Errorf("unknown Deposit unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepositMutation) ResetEdge(name string) error {
	switch name {
	case deposit.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case deposit.EdgeStatusd:
		m.ResetStatusd()
		return nil
	case deposit.EdgeLease:
		m.ResetLease()
		return nil
	}
	return fmt.Errorf("unknown Deposit edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	email                 *string
	password              *string
	clearedFields         map[string]struct{}
	employees             map[int]struct{}
	removedemployees      map[int]struct{}
	leases                map[int]struct{}
	removedleases         map[int]struct{}
	roomdetails           map[int]struct{}
	removedroomdetails    map[int]struct{}
	jobposition           *int
	clearedjobposition    bool
	repairinvoices        map[int]struct{}
	removedrepairinvoices map[int]struct{}
	cleaningrooms         map[int]struct{}
	removedcleaningrooms  map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *EmployeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EmployeeMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *EmployeeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *EmployeeMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *EmployeeMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *EmployeeMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *EmployeeMutation) ResetPassword() {
	m.password = nil
}

// AddEmployeeIDs adds the employees edge to Deposit by ids.
func (m *EmployeeMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Deposit by ids.
func (m *EmployeeMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *EmployeeMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *EmployeeMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *EmployeeMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// AddLeaseIDs adds the leases edge to Lease by ids.
func (m *EmployeeMutation) AddLeaseIDs(ids ...int) {
	if m.leases == nil {
		m.leases = make(map[int]struct{})
	}
	for i := range ids {
		m.leases[ids[i]] = struct{}{}
	}
}

// RemoveLeaseIDs removes the leases edge to Lease by ids.
func (m *EmployeeMutation) RemoveLeaseIDs(ids ...int) {
	if m.removedleases == nil {
		m.removedleases = make(map[int]struct{})
	}
	for i := range ids {
		m.removedleases[ids[i]] = struct{}{}
	}
}

// RemovedLeases returns the removed ids of leases.
func (m *EmployeeMutation) RemovedLeasesIDs() (ids []int) {
	for id := range m.removedleases {
		ids = append(ids, id)
	}
	return
}

// LeasesIDs returns the leases ids in the mutation.
func (m *EmployeeMutation) LeasesIDs() (ids []int) {
	for id := range m.leases {
		ids = append(ids, id)
	}
	return
}

// ResetLeases reset all changes of the "leases" edge.
func (m *EmployeeMutation) ResetLeases() {
	m.leases = nil
	m.removedleases = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *EmployeeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *EmployeeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *EmployeeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *EmployeeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *EmployeeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// SetJobpositionID sets the jobposition edge to Jobposition by id.
func (m *EmployeeMutation) SetJobpositionID(id int) {
	m.jobposition = &id
}

// ClearJobposition clears the jobposition edge to Jobposition.
func (m *EmployeeMutation) ClearJobposition() {
	m.clearedjobposition = true
}

// JobpositionCleared returns if the edge jobposition was cleared.
func (m *EmployeeMutation) JobpositionCleared() bool {
	return m.clearedjobposition
}

// JobpositionID returns the jobposition id in the mutation.
func (m *EmployeeMutation) JobpositionID() (id int, exists bool) {
	if m.jobposition != nil {
		return *m.jobposition, true
	}
	return
}

// JobpositionIDs returns the jobposition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// JobpositionID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) JobpositionIDs() (ids []int) {
	if id := m.jobposition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobposition reset all changes of the "jobposition" edge.
func (m *EmployeeMutation) ResetJobposition() {
	m.jobposition = nil
	m.clearedjobposition = false
}

// AddRepairinvoiceIDs adds the repairinvoices edge to Repairinvoice by ids.
func (m *EmployeeMutation) AddRepairinvoiceIDs(ids ...int) {
	if m.repairinvoices == nil {
		m.repairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.repairinvoices[ids[i]] = struct{}{}
	}
}

// RemoveRepairinvoiceIDs removes the repairinvoices edge to Repairinvoice by ids.
func (m *EmployeeMutation) RemoveRepairinvoiceIDs(ids ...int) {
	if m.removedrepairinvoices == nil {
		m.removedrepairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepairinvoices[ids[i]] = struct{}{}
	}
}

// RemovedRepairinvoices returns the removed ids of repairinvoices.
func (m *EmployeeMutation) RemovedRepairinvoicesIDs() (ids []int) {
	for id := range m.removedrepairinvoices {
		ids = append(ids, id)
	}
	return
}

// RepairinvoicesIDs returns the repairinvoices ids in the mutation.
func (m *EmployeeMutation) RepairinvoicesIDs() (ids []int) {
	for id := range m.repairinvoices {
		ids = append(ids, id)
	}
	return
}

// ResetRepairinvoices reset all changes of the "repairinvoices" edge.
func (m *EmployeeMutation) ResetRepairinvoices() {
	m.repairinvoices = nil
	m.removedrepairinvoices = nil
}

// AddCleaningroomIDs adds the cleaningrooms edge to CleaningRoom by ids.
func (m *EmployeeMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to CleaningRoom by ids.
func (m *EmployeeMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *EmployeeMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *EmployeeMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *EmployeeMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, employee.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldName:
		return m.Name()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.employees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	if m.leases != nil {
		edges = append(edges, employee.EdgeLeases)
	}
	if m.roomdetails != nil {
		edges = append(edges, employee.EdgeRoomdetails)
	}
	if m.jobposition != nil {
		edges = append(edges, employee.EdgeJobposition)
	}
	if m.repairinvoices != nil {
		edges = append(edges, employee.EdgeRepairinvoices)
	}
	if m.cleaningrooms != nil {
		edges = append(edges, employee.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeLeases:
		ids := make([]ent.Value, 0, len(m.leases))
		for id := range m.leases {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeJobposition:
		if id := m.jobposition; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.repairinvoices))
		for id := range m.repairinvoices {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedemployees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	if m.removedleases != nil {
		edges = append(edges, employee.EdgeLeases)
	}
	if m.removedroomdetails != nil {
		edges = append(edges, employee.EdgeRoomdetails)
	}
	if m.removedrepairinvoices != nil {
		edges = append(edges, employee.EdgeRepairinvoices)
	}
	if m.removedcleaningrooms != nil {
		edges = append(edges, employee.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeLeases:
		ids := make([]ent.Value, 0, len(m.removedleases))
		for id := range m.removedleases {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.removedrepairinvoices))
		for id := range m.removedrepairinvoices {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedjobposition {
		edges = append(edges, employee.EdgeJobposition)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeJobposition:
		return m.clearedjobposition
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeJobposition:
		m.ClearJobposition()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case employee.EdgeLeases:
		m.ResetLeases()
		return nil
	case employee.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	case employee.EdgeJobposition:
		m.ResetJobposition()
		return nil
	case employee.EdgeRepairinvoices:
		m.ResetRepairinvoices()
		return nil
	case employee.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// JobpositionMutation represents an operation that mutate the Jobpositions
// nodes in the graph.
type JobpositionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	positionname     *string
	clearedFields    map[string]struct{}
	employees        map[int]struct{}
	removedemployees map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Jobposition, error)
}

var _ ent.Mutation = (*JobpositionMutation)(nil)

// jobpositionOption allows to manage the mutation configuration using functional options.
type jobpositionOption func(*JobpositionMutation)

// newJobpositionMutation creates new mutation for $n.Name.
func newJobpositionMutation(c config, op Op, opts ...jobpositionOption) *JobpositionMutation {
	m := &JobpositionMutation{
		config:        c,
		op:            op,
		typ:           TypeJobposition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobpositionID sets the id field of the mutation.
func withJobpositionID(id int) jobpositionOption {
	return func(m *JobpositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Jobposition
		)
		m.oldValue = func(ctx context.Context) (*Jobposition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Jobposition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobposition sets the old Jobposition of the mutation.
func withJobposition(node *Jobposition) jobpositionOption {
	return func(m *JobpositionMutation) {
		m.oldValue = func(context.Context) (*Jobposition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobpositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobpositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *JobpositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPositionname sets the positionname field.
func (m *JobpositionMutation) SetPositionname(s string) {
	m.positionname = &s
}

// Positionname returns the positionname value in the mutation.
func (m *JobpositionMutation) Positionname() (r string, exists bool) {
	v := m.positionname
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionname returns the old positionname value of the Jobposition.
// If the Jobposition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *JobpositionMutation) OldPositionname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionname: %w", err)
	}
	return oldValue.Positionname, nil
}

// ResetPositionname reset all changes of the "positionname" field.
func (m *JobpositionMutation) ResetPositionname() {
	m.positionname = nil
}

// AddEmployeeIDs adds the employees edge to Employee by ids.
func (m *JobpositionMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Employee by ids.
func (m *JobpositionMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *JobpositionMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *JobpositionMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *JobpositionMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// Op returns the operation name.
func (m *JobpositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Jobposition).
func (m *JobpositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *JobpositionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.positionname != nil {
		fields = append(fields, jobposition.FieldPositionname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *JobpositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobposition.FieldPositionname:
		return m.Positionname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *JobpositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobposition.FieldPositionname:
		return m.OldPositionname(ctx)
	}
	return nil, fmt.Errorf("unknown Jobposition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *JobpositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobposition.FieldPositionname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionname(v)
		return nil
	}
	return fmt.Errorf("unknown Jobposition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *JobpositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *JobpositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *JobpositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Jobposition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *JobpositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *JobpositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobpositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Jobposition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *JobpositionMutation) ResetField(name string) error {
	switch name {
	case jobposition.FieldPositionname:
		m.ResetPositionname()
		return nil
	}
	return fmt.Errorf("unknown Jobposition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *JobpositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employees != nil {
		edges = append(edges, jobposition.EdgeEmployees)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *JobpositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *JobpositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployees != nil {
		edges = append(edges, jobposition.EdgeEmployees)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *JobpositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *JobpositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *JobpositionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *JobpositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Jobposition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *JobpositionMutation) ResetEdge(name string) error {
	switch name {
	case jobposition.EdgeEmployees:
		m.ResetEmployees()
		return nil
	}
	return fmt.Errorf("unknown Jobposition edge %s", name)
}

// LeaseMutation represents an operation that mutate the Leases
// nodes in the graph.
type LeaseMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	addedtime          *time.Time
	tenant             *string
	clearedFields      map[string]struct{}
	_Wifi              *int
	cleared_Wifi       bool
	_Roomdetail        *int
	cleared_Roomdetail bool
	employee           *int
	clearedemployee    bool
	leases             map[int]struct{}
	removedleases      map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Lease, error)
}

var _ ent.Mutation = (*LeaseMutation)(nil)

// leaseOption allows to manage the mutation configuration using functional options.
type leaseOption func(*LeaseMutation)

// newLeaseMutation creates new mutation for $n.Name.
func newLeaseMutation(c config, op Op, opts ...leaseOption) *LeaseMutation {
	m := &LeaseMutation{
		config:        c,
		op:            op,
		typ:           TypeLease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeaseID sets the id field of the mutation.
func withLeaseID(id int) leaseOption {
	return func(m *LeaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Lease
		)
		m.oldValue = func(ctx context.Context) (*Lease, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLease sets the old Lease of the mutation.
func withLease(node *Lease) leaseOption {
	return func(m *LeaseMutation) {
		m.oldValue = func(context.Context) (*Lease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LeaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *LeaseMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *LeaseMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Lease.
// If the Lease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LeaseMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *LeaseMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetTenant sets the tenant field.
func (m *LeaseMutation) SetTenant(s string) {
	m.tenant = &s
}

// Tenant returns the tenant value in the mutation.
func (m *LeaseMutation) Tenant() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenant returns the old tenant value of the Lease.
// If the Lease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LeaseMutation) OldTenant(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenant is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenant: %w", err)
	}
	return oldValue.Tenant, nil
}

// ResetTenant reset all changes of the "tenant" field.
func (m *LeaseMutation) ResetTenant() {
	m.tenant = nil
}

// SetWifiID sets the Wifi edge to Wifi by id.
func (m *LeaseMutation) SetWifiID(id int) {
	m._Wifi = &id
}

// ClearWifi clears the Wifi edge to Wifi.
func (m *LeaseMutation) ClearWifi() {
	m.cleared_Wifi = true
}

// WifiCleared returns if the edge Wifi was cleared.
func (m *LeaseMutation) WifiCleared() bool {
	return m.cleared_Wifi
}

// WifiID returns the Wifi id in the mutation.
func (m *LeaseMutation) WifiID() (id int, exists bool) {
	if m._Wifi != nil {
		return *m._Wifi, true
	}
	return
}

// WifiIDs returns the Wifi ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WifiID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) WifiIDs() (ids []int) {
	if id := m._Wifi; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWifi reset all changes of the "Wifi" edge.
func (m *LeaseMutation) ResetWifi() {
	m._Wifi = nil
	m.cleared_Wifi = false
}

// SetRoomdetailID sets the Roomdetail edge to Roomdetail by id.
func (m *LeaseMutation) SetRoomdetailID(id int) {
	m._Roomdetail = &id
}

// ClearRoomdetail clears the Roomdetail edge to Roomdetail.
func (m *LeaseMutation) ClearRoomdetail() {
	m.cleared_Roomdetail = true
}

// RoomdetailCleared returns if the edge Roomdetail was cleared.
func (m *LeaseMutation) RoomdetailCleared() bool {
	return m.cleared_Roomdetail
}

// RoomdetailID returns the Roomdetail id in the mutation.
func (m *LeaseMutation) RoomdetailID() (id int, exists bool) {
	if m._Roomdetail != nil {
		return *m._Roomdetail, true
	}
	return
}

// RoomdetailIDs returns the Roomdetail ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomdetailID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) RoomdetailIDs() (ids []int) {
	if id := m._Roomdetail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomdetail reset all changes of the "Roomdetail" edge.
func (m *LeaseMutation) ResetRoomdetail() {
	m._Roomdetail = nil
	m.cleared_Roomdetail = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *LeaseMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *LeaseMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *LeaseMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *LeaseMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *LeaseMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// AddLeaseIDs adds the leases edge to Deposit by ids.
func (m *LeaseMutation) AddLeaseIDs(ids ...int) {
	if m.leases == nil {
		m.leases = make(map[int]struct{})
	}
	for i := range ids {
		m.leases[ids[i]] = struct{}{}
	}
}

// RemoveLeaseIDs removes the leases edge to Deposit by ids.
func (m *LeaseMutation) RemoveLeaseIDs(ids ...int) {
	if m.removedleases == nil {
		m.removedleases = make(map[int]struct{})
	}
	for i := range ids {
		m.removedleases[ids[i]] = struct{}{}
	}
}

// RemovedLeases returns the removed ids of leases.
func (m *LeaseMutation) RemovedLeasesIDs() (ids []int) {
	for id := range m.removedleases {
		ids = append(ids, id)
	}
	return
}

// LeasesIDs returns the leases ids in the mutation.
func (m *LeaseMutation) LeasesIDs() (ids []int) {
	for id := range m.leases {
		ids = append(ids, id)
	}
	return
}

// ResetLeases reset all changes of the "leases" edge.
func (m *LeaseMutation) ResetLeases() {
	m.leases = nil
	m.removedleases = nil
}

// Op returns the operation name.
func (m *LeaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Lease).
func (m *LeaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LeaseMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.addedtime != nil {
		fields = append(fields, lease.FieldAddedtime)
	}
	if m.tenant != nil {
		fields = append(fields, lease.FieldTenant)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LeaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lease.FieldAddedtime:
		return m.Addedtime()
	case lease.FieldTenant:
		return m.Tenant()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LeaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lease.FieldAddedtime:
		return m.OldAddedtime(ctx)
	case lease.FieldTenant:
		return m.OldTenant(ctx)
	}
	return nil, fmt.Errorf("unknown Lease field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LeaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lease.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	case lease.FieldTenant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenant(v)
		return nil
	}
	return fmt.Errorf("unknown Lease field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LeaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LeaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LeaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Lease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LeaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LeaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Lease nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LeaseMutation) ResetField(name string) error {
	switch name {
	case lease.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	case lease.FieldTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Lease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LeaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Wifi != nil {
		edges = append(edges, lease.EdgeWifi)
	}
	if m._Roomdetail != nil {
		edges = append(edges, lease.EdgeRoomdetail)
	}
	if m.employee != nil {
		edges = append(edges, lease.EdgeEmployee)
	}
	if m.leases != nil {
		edges = append(edges, lease.EdgeLeases)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LeaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lease.EdgeWifi:
		if id := m._Wifi; id != nil {
			return []ent.Value{*id}
		}
	case lease.EdgeRoomdetail:
		if id := m._Roomdetail; id != nil {
			return []ent.Value{*id}
		}
	case lease.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case lease.EdgeLeases:
		ids := make([]ent.Value, 0, len(m.leases))
		for id := range m.leases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LeaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedleases != nil {
		edges = append(edges, lease.EdgeLeases)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LeaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lease.EdgeLeases:
		ids := make([]ent.Value, 0, len(m.removedleases))
		for id := range m.removedleases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LeaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Wifi {
		edges = append(edges, lease.EdgeWifi)
	}
	if m.cleared_Roomdetail {
		edges = append(edges, lease.EdgeRoomdetail)
	}
	if m.clearedemployee {
		edges = append(edges, lease.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LeaseMutation) EdgeCleared(name string) bool {
	switch name {
	case lease.EdgeWifi:
		return m.cleared_Wifi
	case lease.EdgeRoomdetail:
		return m.cleared_Roomdetail
	case lease.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LeaseMutation) ClearEdge(name string) error {
	switch name {
	case lease.EdgeWifi:
		m.ClearWifi()
		return nil
	case lease.EdgeRoomdetail:
		m.ClearRoomdetail()
		return nil
	case lease.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Lease unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LeaseMutation) ResetEdge(name string) error {
	switch name {
	case lease.EdgeWifi:
		m.ResetWifi()
		return nil
	case lease.EdgeRoomdetail:
		m.ResetRoomdetail()
		return nil
	case lease.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case lease.EdgeLeases:
		m.ResetLeases()
		return nil
	}
	return fmt.Errorf("unknown Lease edge %s", name)
}

// LengthTimeMutation represents an operation that mutate the LengthTimes
// nodes in the graph.
type LengthTimeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	lengthtime           *string
	clearedFields        map[string]struct{}
	cleaningrooms        map[int]struct{}
	removedcleaningrooms map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*LengthTime, error)
}

var _ ent.Mutation = (*LengthTimeMutation)(nil)

// lengthtimeOption allows to manage the mutation configuration using functional options.
type lengthtimeOption func(*LengthTimeMutation)

// newLengthTimeMutation creates new mutation for $n.Name.
func newLengthTimeMutation(c config, op Op, opts ...lengthtimeOption) *LengthTimeMutation {
	m := &LengthTimeMutation{
		config:        c,
		op:            op,
		typ:           TypeLengthTime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLengthTimeID sets the id field of the mutation.
func withLengthTimeID(id int) lengthtimeOption {
	return func(m *LengthTimeMutation) {
		var (
			err   error
			once  sync.Once
			value *LengthTime
		)
		m.oldValue = func(ctx context.Context) (*LengthTime, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LengthTime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLengthTime sets the old LengthTime of the mutation.
func withLengthTime(node *LengthTime) lengthtimeOption {
	return func(m *LengthTimeMutation) {
		m.oldValue = func(context.Context) (*LengthTime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LengthTimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LengthTimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LengthTimeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLengthtime sets the lengthtime field.
func (m *LengthTimeMutation) SetLengthtime(s string) {
	m.lengthtime = &s
}

// Lengthtime returns the lengthtime value in the mutation.
func (m *LengthTimeMutation) Lengthtime() (r string, exists bool) {
	v := m.lengthtime
	if v == nil {
		return
	}
	return *v, true
}

// OldLengthtime returns the old lengthtime value of the LengthTime.
// If the LengthTime object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LengthTimeMutation) OldLengthtime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLengthtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLengthtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLengthtime: %w", err)
	}
	return oldValue.Lengthtime, nil
}

// ResetLengthtime reset all changes of the "lengthtime" field.
func (m *LengthTimeMutation) ResetLengthtime() {
	m.lengthtime = nil
}

// AddCleaningroomIDs adds the cleaningrooms edge to CleaningRoom by ids.
func (m *LengthTimeMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to CleaningRoom by ids.
func (m *LengthTimeMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *LengthTimeMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *LengthTimeMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *LengthTimeMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *LengthTimeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LengthTime).
func (m *LengthTimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LengthTimeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.lengthtime != nil {
		fields = append(fields, lengthtime.FieldLengthtime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LengthTimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lengthtime.FieldLengthtime:
		return m.Lengthtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LengthTimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lengthtime.FieldLengthtime:
		return m.OldLengthtime(ctx)
	}
	return nil, fmt.Errorf("unknown LengthTime field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LengthTimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lengthtime.FieldLengthtime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLengthtime(v)
		return nil
	}
	return fmt.Errorf("unknown LengthTime field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LengthTimeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LengthTimeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LengthTimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LengthTime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LengthTimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LengthTimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LengthTimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LengthTime nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LengthTimeMutation) ResetField(name string) error {
	switch name {
	case lengthtime.FieldLengthtime:
		m.ResetLengthtime()
		return nil
	}
	return fmt.Errorf("unknown LengthTime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LengthTimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleaningrooms != nil {
		edges = append(edges, lengthtime.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LengthTimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lengthtime.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LengthTimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcleaningrooms != nil {
		edges = append(edges, lengthtime.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LengthTimeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lengthtime.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LengthTimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LengthTimeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LengthTimeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LengthTime unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LengthTimeMutation) ResetEdge(name string) error {
	switch name {
	case lengthtime.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown LengthTime edge %s", name)
}

// PaymentMutation represents an operation that mutate the Payments
// nodes in the graph.
type PaymentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	paymentname     *string
	clearedFields   map[string]struct{}
	payments        map[int]struct{}
	removedpayments map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Payment, error)
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows to manage the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for $n.Name.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the id field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPaymentname sets the paymentname field.
func (m *PaymentMutation) SetPaymentname(s string) {
	m.paymentname = &s
}

// Paymentname returns the paymentname value in the mutation.
func (m *PaymentMutation) Paymentname() (r string, exists bool) {
	v := m.paymentname
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentname returns the old paymentname value of the Payment.
// If the Payment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymentMutation) OldPaymentname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentname: %w", err)
	}
	return oldValue.Paymentname, nil
}

// ResetPaymentname reset all changes of the "paymentname" field.
func (m *PaymentMutation) ResetPaymentname() {
	m.paymentname = nil
}

// AddPaymentIDs adds the payments edge to Bill by ids.
func (m *PaymentMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payments edge to Bill by ids.
func (m *PaymentMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed ids of payments.
func (m *PaymentMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the payments ids in the mutation.
func (m *PaymentMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments reset all changes of the "payments" edge.
func (m *PaymentMutation) ResetPayments() {
	m.payments = nil
	m.removedpayments = nil
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.paymentname != nil {
		fields = append(fields, payment.FieldPaymentname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldPaymentname:
		return m.Paymentname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldPaymentname:
		return m.OldPaymentname(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldPaymentname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentname(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldPaymentname:
		m.ResetPaymentname()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payments != nil {
		edges = append(edges, payment.EdgePayments)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpayments != nil {
		edges = append(edges, payment.EdgePayments)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgePayments:
		m.ResetPayments()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PetruleMutation represents an operation that mutate the Petrules
// nodes in the graph.
type PetruleMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	petrule            *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Petrule, error)
}

var _ ent.Mutation = (*PetruleMutation)(nil)

// petruleOption allows to manage the mutation configuration using functional options.
type petruleOption func(*PetruleMutation)

// newPetruleMutation creates new mutation for $n.Name.
func newPetruleMutation(c config, op Op, opts ...petruleOption) *PetruleMutation {
	m := &PetruleMutation{
		config:        c,
		op:            op,
		typ:           TypePetrule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPetruleID sets the id field of the mutation.
func withPetruleID(id int) petruleOption {
	return func(m *PetruleMutation) {
		var (
			err   error
			once  sync.Once
			value *Petrule
		)
		m.oldValue = func(ctx context.Context) (*Petrule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Petrule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPetrule sets the old Petrule of the mutation.
func withPetrule(node *Petrule) petruleOption {
	return func(m *PetruleMutation) {
		m.oldValue = func(context.Context) (*Petrule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PetruleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PetruleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PetruleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPetrule sets the petrule field.
func (m *PetruleMutation) SetPetrule(s string) {
	m.petrule = &s
}

// Petrule returns the petrule value in the mutation.
func (m *PetruleMutation) Petrule() (r string, exists bool) {
	v := m.petrule
	if v == nil {
		return
	}
	return *v, true
}

// OldPetrule returns the old petrule value of the Petrule.
// If the Petrule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PetruleMutation) OldPetrule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPetrule is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPetrule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPetrule: %w", err)
	}
	return oldValue.Petrule, nil
}

// ResetPetrule reset all changes of the "petrule" field.
func (m *PetruleMutation) ResetPetrule() {
	m.petrule = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *PetruleMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *PetruleMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *PetruleMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *PetruleMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *PetruleMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *PetruleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Petrule).
func (m *PetruleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PetruleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.petrule != nil {
		fields = append(fields, petrule.FieldPetrule)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PetruleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case petrule.FieldPetrule:
		return m.Petrule()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PetruleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case petrule.FieldPetrule:
		return m.OldPetrule(ctx)
	}
	return nil, fmt.Errorf("unknown Petrule field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PetruleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case petrule.FieldPetrule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPetrule(v)
		return nil
	}
	return fmt.Errorf("unknown Petrule field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PetruleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PetruleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PetruleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Petrule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PetruleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PetruleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PetruleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Petrule nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PetruleMutation) ResetField(name string) error {
	switch name {
	case petrule.FieldPetrule:
		m.ResetPetrule()
		return nil
	}
	return fmt.Errorf("unknown Petrule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PetruleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, petrule.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PetruleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case petrule.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PetruleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, petrule.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PetruleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case petrule.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PetruleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PetruleMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PetruleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Petrule unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PetruleMutation) ResetEdge(name string) error {
	switch name {
	case petrule.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Petrule edge %s", name)
}

// PledgeMutation represents an operation that mutate the Pledges
// nodes in the graph.
type PledgeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	provision          *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Pledge, error)
}

var _ ent.Mutation = (*PledgeMutation)(nil)

// pledgeOption allows to manage the mutation configuration using functional options.
type pledgeOption func(*PledgeMutation)

// newPledgeMutation creates new mutation for $n.Name.
func newPledgeMutation(c config, op Op, opts ...pledgeOption) *PledgeMutation {
	m := &PledgeMutation{
		config:        c,
		op:            op,
		typ:           TypePledge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPledgeID sets the id field of the mutation.
func withPledgeID(id int) pledgeOption {
	return func(m *PledgeMutation) {
		var (
			err   error
			once  sync.Once
			value *Pledge
		)
		m.oldValue = func(ctx context.Context) (*Pledge, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pledge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPledge sets the old Pledge of the mutation.
func withPledge(node *Pledge) pledgeOption {
	return func(m *PledgeMutation) {
		m.oldValue = func(context.Context) (*Pledge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PledgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PledgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PledgeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProvision sets the provision field.
func (m *PledgeMutation) SetProvision(s string) {
	m.provision = &s
}

// Provision returns the provision value in the mutation.
func (m *PledgeMutation) Provision() (r string, exists bool) {
	v := m.provision
	if v == nil {
		return
	}
	return *v, true
}

// OldProvision returns the old provision value of the Pledge.
// If the Pledge object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PledgeMutation) OldProvision(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvision is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvision: %w", err)
	}
	return oldValue.Provision, nil
}

// ResetProvision reset all changes of the "provision" field.
func (m *PledgeMutation) ResetProvision() {
	m.provision = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *PledgeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *PledgeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *PledgeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *PledgeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *PledgeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *PledgeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pledge).
func (m *PledgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PledgeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.provision != nil {
		fields = append(fields, pledge.FieldProvision)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PledgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pledge.FieldProvision:
		return m.Provision()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PledgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pledge.FieldProvision:
		return m.OldProvision(ctx)
	}
	return nil, fmt.Errorf("unknown Pledge field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PledgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pledge.FieldProvision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvision(v)
		return nil
	}
	return fmt.Errorf("unknown Pledge field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PledgeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PledgeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PledgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pledge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PledgeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PledgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PledgeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pledge nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PledgeMutation) ResetField(name string) error {
	switch name {
	case pledge.FieldProvision:
		m.ResetProvision()
		return nil
	}
	return fmt.Errorf("unknown Pledge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PledgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, pledge.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PledgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pledge.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PledgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, pledge.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PledgeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pledge.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PledgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PledgeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PledgeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Pledge unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PledgeMutation) ResetEdge(name string) error {
	switch name {
	case pledge.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Pledge edge %s", name)
}

// RentalstatusMutation represents an operation that mutate the Rentalstatuses
// nodes in the graph.
type RentalstatusMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	rentalstatus          *string
	clearedFields         map[string]struct{}
	repairinvoices        map[int]struct{}
	removedrepairinvoices map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Rentalstatus, error)
}

var _ ent.Mutation = (*RentalstatusMutation)(nil)

// rentalstatusOption allows to manage the mutation configuration using functional options.
type rentalstatusOption func(*RentalstatusMutation)

// newRentalstatusMutation creates new mutation for $n.Name.
func newRentalstatusMutation(c config, op Op, opts ...rentalstatusOption) *RentalstatusMutation {
	m := &RentalstatusMutation{
		config:        c,
		op:            op,
		typ:           TypeRentalstatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRentalstatusID sets the id field of the mutation.
func withRentalstatusID(id int) rentalstatusOption {
	return func(m *RentalstatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Rentalstatus
		)
		m.oldValue = func(ctx context.Context) (*Rentalstatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rentalstatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRentalstatus sets the old Rentalstatus of the mutation.
func withRentalstatus(node *Rentalstatus) rentalstatusOption {
	return func(m *RentalstatusMutation) {
		m.oldValue = func(context.Context) (*Rentalstatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RentalstatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RentalstatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RentalstatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRentalstatus sets the rentalstatus field.
func (m *RentalstatusMutation) SetRentalstatus(s string) {
	m.rentalstatus = &s
}

// Rentalstatus returns the rentalstatus value in the mutation.
func (m *RentalstatusMutation) Rentalstatus() (r string, exists bool) {
	v := m.rentalstatus
	if v == nil {
		return
	}
	return *v, true
}

// OldRentalstatus returns the old rentalstatus value of the Rentalstatus.
// If the Rentalstatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RentalstatusMutation) OldRentalstatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRentalstatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRentalstatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRentalstatus: %w", err)
	}
	return oldValue.Rentalstatus, nil
}

// ResetRentalstatus reset all changes of the "rentalstatus" field.
func (m *RentalstatusMutation) ResetRentalstatus() {
	m.rentalstatus = nil
}

// AddRepairinvoiceIDs adds the repairinvoices edge to Repairinvoice by ids.
func (m *RentalstatusMutation) AddRepairinvoiceIDs(ids ...int) {
	if m.repairinvoices == nil {
		m.repairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.repairinvoices[ids[i]] = struct{}{}
	}
}

// RemoveRepairinvoiceIDs removes the repairinvoices edge to Repairinvoice by ids.
func (m *RentalstatusMutation) RemoveRepairinvoiceIDs(ids ...int) {
	if m.removedrepairinvoices == nil {
		m.removedrepairinvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepairinvoices[ids[i]] = struct{}{}
	}
}

// RemovedRepairinvoices returns the removed ids of repairinvoices.
func (m *RentalstatusMutation) RemovedRepairinvoicesIDs() (ids []int) {
	for id := range m.removedrepairinvoices {
		ids = append(ids, id)
	}
	return
}

// RepairinvoicesIDs returns the repairinvoices ids in the mutation.
func (m *RentalstatusMutation) RepairinvoicesIDs() (ids []int) {
	for id := range m.repairinvoices {
		ids = append(ids, id)
	}
	return
}

// ResetRepairinvoices reset all changes of the "repairinvoices" edge.
func (m *RentalstatusMutation) ResetRepairinvoices() {
	m.repairinvoices = nil
	m.removedrepairinvoices = nil
}

// Op returns the operation name.
func (m *RentalstatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Rentalstatus).
func (m *RentalstatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RentalstatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.rentalstatus != nil {
		fields = append(fields, rentalstatus.FieldRentalstatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RentalstatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rentalstatus.FieldRentalstatus:
		return m.Rentalstatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RentalstatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rentalstatus.FieldRentalstatus:
		return m.OldRentalstatus(ctx)
	}
	return nil, fmt.Errorf("unknown Rentalstatus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RentalstatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rentalstatus.FieldRentalstatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRentalstatus(v)
		return nil
	}
	return fmt.Errorf("unknown Rentalstatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RentalstatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RentalstatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RentalstatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rentalstatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RentalstatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RentalstatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RentalstatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Rentalstatus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RentalstatusMutation) ResetField(name string) error {
	switch name {
	case rentalstatus.FieldRentalstatus:
		m.ResetRentalstatus()
		return nil
	}
	return fmt.Errorf("unknown Rentalstatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RentalstatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repairinvoices != nil {
		edges = append(edges, rentalstatus.EdgeRepairinvoices)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RentalstatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rentalstatus.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.repairinvoices))
		for id := range m.repairinvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RentalstatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrepairinvoices != nil {
		edges = append(edges, rentalstatus.EdgeRepairinvoices)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RentalstatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rentalstatus.EdgeRepairinvoices:
		ids := make([]ent.Value, 0, len(m.removedrepairinvoices))
		for id := range m.removedrepairinvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RentalstatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RentalstatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RentalstatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Rentalstatus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RentalstatusMutation) ResetEdge(name string) error {
	switch name {
	case rentalstatus.EdgeRepairinvoices:
		m.ResetRepairinvoices()
		return nil
	}
	return fmt.Errorf("unknown Rentalstatus edge %s", name)
}

// RepairinvoiceMutation represents an operation that mutate the Repairinvoices
// nodes in the graph.
type RepairinvoiceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	bequipment           *string
	clearedFields        map[string]struct{}
	employee             *int
	clearedemployee      bool
	_Rentalstatus        *int
	cleared_Rentalstatus bool
	done                 bool
	oldValue             func(context.Context) (*Repairinvoice, error)
}

var _ ent.Mutation = (*RepairinvoiceMutation)(nil)

// repairinvoiceOption allows to manage the mutation configuration using functional options.
type repairinvoiceOption func(*RepairinvoiceMutation)

// newRepairinvoiceMutation creates new mutation for $n.Name.
func newRepairinvoiceMutation(c config, op Op, opts ...repairinvoiceOption) *RepairinvoiceMutation {
	m := &RepairinvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeRepairinvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepairinvoiceID sets the id field of the mutation.
func withRepairinvoiceID(id int) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Repairinvoice
		)
		m.oldValue = func(ctx context.Context) (*Repairinvoice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repairinvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepairinvoice sets the old Repairinvoice of the mutation.
func withRepairinvoice(node *Repairinvoice) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		m.oldValue = func(context.Context) (*Repairinvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepairinvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepairinvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RepairinvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBequipment sets the bequipment field.
func (m *RepairinvoiceMutation) SetBequipment(s string) {
	m.bequipment = &s
}

// Bequipment returns the bequipment value in the mutation.
func (m *RepairinvoiceMutation) Bequipment() (r string, exists bool) {
	v := m.bequipment
	if v == nil {
		return
	}
	return *v, true
}

// OldBequipment returns the old bequipment value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldBequipment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBequipment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBequipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBequipment: %w", err)
	}
	return oldValue.Bequipment, nil
}

// ResetBequipment reset all changes of the "bequipment" field.
func (m *RepairinvoiceMutation) ResetBequipment() {
	m.bequipment = nil
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *RepairinvoiceMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *RepairinvoiceMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *RepairinvoiceMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *RepairinvoiceMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *RepairinvoiceMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *RepairinvoiceMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetRentalstatusID sets the Rentalstatus edge to Rentalstatus by id.
func (m *RepairinvoiceMutation) SetRentalstatusID(id int) {
	m._Rentalstatus = &id
}

// ClearRentalstatus clears the Rentalstatus edge to Rentalstatus.
func (m *RepairinvoiceMutation) ClearRentalstatus() {
	m.cleared_Rentalstatus = true
}

// RentalstatusCleared returns if the edge Rentalstatus was cleared.
func (m *RepairinvoiceMutation) RentalstatusCleared() bool {
	return m.cleared_Rentalstatus
}

// RentalstatusID returns the Rentalstatus id in the mutation.
func (m *RepairinvoiceMutation) RentalstatusID() (id int, exists bool) {
	if m._Rentalstatus != nil {
		return *m._Rentalstatus, true
	}
	return
}

// RentalstatusIDs returns the Rentalstatus ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RentalstatusID instead. It exists only for internal usage by the builders.
func (m *RepairinvoiceMutation) RentalstatusIDs() (ids []int) {
	if id := m._Rentalstatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRentalstatus reset all changes of the "Rentalstatus" edge.
func (m *RepairinvoiceMutation) ResetRentalstatus() {
	m._Rentalstatus = nil
	m.cleared_Rentalstatus = false
}

// Op returns the operation name.
func (m *RepairinvoiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repairinvoice).
func (m *RepairinvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RepairinvoiceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.bequipment != nil {
		fields = append(fields, repairinvoice.FieldBequipment)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RepairinvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldBequipment:
		return m.Bequipment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RepairinvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repairinvoice.FieldBequipment:
		return m.OldBequipment(ctx)
	}
	return nil, fmt.Errorf("unknown Repairinvoice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldBequipment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBequipment(v)
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RepairinvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RepairinvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repairinvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RepairinvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RepairinvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepairinvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repairinvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetField(name string) error {
	switch name {
	case repairinvoice.FieldBequipment:
		m.ResetBequipment()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RepairinvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.employee != nil {
		edges = append(edges, repairinvoice.EdgeEmployee)
	}
	if m._Rentalstatus != nil {
		edges = append(edges, repairinvoice.EdgeRentalstatus)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RepairinvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repairinvoice.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case repairinvoice.EdgeRentalstatus:
		if id := m._Rentalstatus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RepairinvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RepairinvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RepairinvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedemployee {
		edges = append(edges, repairinvoice.EdgeEmployee)
	}
	if m.cleared_Rentalstatus {
		edges = append(edges, repairinvoice.EdgeRentalstatus)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RepairinvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case repairinvoice.EdgeEmployee:
		return m.clearedemployee
	case repairinvoice.EdgeRentalstatus:
		return m.cleared_Rentalstatus
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RepairinvoiceMutation) ClearEdge(name string) error {
	switch name {
	case repairinvoice.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case repairinvoice.EdgeRentalstatus:
		m.ClearRentalstatus()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetEdge(name string) error {
	switch name {
	case repairinvoice.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case repairinvoice.EdgeRentalstatus:
		m.ResetRentalstatus()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice edge %s", name)
}

// RoomdetailMutation represents an operation that mutate the Roomdetails
// nodes in the graph.
type RoomdetailMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	roomnumber           *string
	roomtypename         *string
	roomprice            *string
	sleep                *string
	bed                  *string
	clearedFields        map[string]struct{}
	pledge               *int
	clearedpledge        bool
	petrule              *int
	clearedpetrule       bool
	bedtype              *int
	clearedbedtype       bool
	employee             *int
	clearedemployee      bool
	staytype             *int
	clearedstaytype      bool
	roomdetails          *int
	clearedroomdetails   bool
	cleaningrooms        map[int]struct{}
	removedcleaningrooms map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Roomdetail, error)
}

var _ ent.Mutation = (*RoomdetailMutation)(nil)

// roomdetailOption allows to manage the mutation configuration using functional options.
type roomdetailOption func(*RoomdetailMutation)

// newRoomdetailMutation creates new mutation for $n.Name.
func newRoomdetailMutation(c config, op Op, opts ...roomdetailOption) *RoomdetailMutation {
	m := &RoomdetailMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomdetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomdetailID sets the id field of the mutation.
func withRoomdetailID(id int) roomdetailOption {
	return func(m *RoomdetailMutation) {
		var (
			err   error
			once  sync.Once
			value *Roomdetail
		)
		m.oldValue = func(ctx context.Context) (*Roomdetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Roomdetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomdetail sets the old Roomdetail of the mutation.
func withRoomdetail(node *Roomdetail) roomdetailOption {
	return func(m *RoomdetailMutation) {
		m.oldValue = func(context.Context) (*Roomdetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomdetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomdetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomdetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomnumber sets the roomnumber field.
func (m *RoomdetailMutation) SetRoomnumber(s string) {
	m.roomnumber = &s
}

// Roomnumber returns the roomnumber value in the mutation.
func (m *RoomdetailMutation) Roomnumber() (r string, exists bool) {
	v := m.roomnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomnumber returns the old roomnumber value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldRoomnumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomnumber: %w", err)
	}
	return oldValue.Roomnumber, nil
}

// ResetRoomnumber reset all changes of the "roomnumber" field.
func (m *RoomdetailMutation) ResetRoomnumber() {
	m.roomnumber = nil
}

// SetRoomtypename sets the roomtypename field.
func (m *RoomdetailMutation) SetRoomtypename(s string) {
	m.roomtypename = &s
}

// Roomtypename returns the roomtypename value in the mutation.
func (m *RoomdetailMutation) Roomtypename() (r string, exists bool) {
	v := m.roomtypename
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomtypename returns the old roomtypename value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldRoomtypename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomtypename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomtypename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomtypename: %w", err)
	}
	return oldValue.Roomtypename, nil
}

// ResetRoomtypename reset all changes of the "roomtypename" field.
func (m *RoomdetailMutation) ResetRoomtypename() {
	m.roomtypename = nil
}

// SetRoomprice sets the roomprice field.
func (m *RoomdetailMutation) SetRoomprice(s string) {
	m.roomprice = &s
}

// Roomprice returns the roomprice value in the mutation.
func (m *RoomdetailMutation) Roomprice() (r string, exists bool) {
	v := m.roomprice
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomprice returns the old roomprice value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldRoomprice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomprice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomprice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomprice: %w", err)
	}
	return oldValue.Roomprice, nil
}

// ResetRoomprice reset all changes of the "roomprice" field.
func (m *RoomdetailMutation) ResetRoomprice() {
	m.roomprice = nil
}

// SetSleep sets the sleep field.
func (m *RoomdetailMutation) SetSleep(s string) {
	m.sleep = &s
}

// Sleep returns the sleep value in the mutation.
func (m *RoomdetailMutation) Sleep() (r string, exists bool) {
	v := m.sleep
	if v == nil {
		return
	}
	return *v, true
}

// OldSleep returns the old sleep value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldSleep(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSleep is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSleep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSleep: %w", err)
	}
	return oldValue.Sleep, nil
}

// ResetSleep reset all changes of the "sleep" field.
func (m *RoomdetailMutation) ResetSleep() {
	m.sleep = nil
}

// SetBed sets the bed field.
func (m *RoomdetailMutation) SetBed(s string) {
	m.bed = &s
}

// Bed returns the bed value in the mutation.
func (m *RoomdetailMutation) Bed() (r string, exists bool) {
	v := m.bed
	if v == nil {
		return
	}
	return *v, true
}

// OldBed returns the old bed value of the Roomdetail.
// If the Roomdetail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomdetailMutation) OldBed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBed: %w", err)
	}
	return oldValue.Bed, nil
}

// ResetBed reset all changes of the "bed" field.
func (m *RoomdetailMutation) ResetBed() {
	m.bed = nil
}

// SetPledgeID sets the pledge edge to Pledge by id.
func (m *RoomdetailMutation) SetPledgeID(id int) {
	m.pledge = &id
}

// ClearPledge clears the pledge edge to Pledge.
func (m *RoomdetailMutation) ClearPledge() {
	m.clearedpledge = true
}

// PledgeCleared returns if the edge pledge was cleared.
func (m *RoomdetailMutation) PledgeCleared() bool {
	return m.clearedpledge
}

// PledgeID returns the pledge id in the mutation.
func (m *RoomdetailMutation) PledgeID() (id int, exists bool) {
	if m.pledge != nil {
		return *m.pledge, true
	}
	return
}

// PledgeIDs returns the pledge ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PledgeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) PledgeIDs() (ids []int) {
	if id := m.pledge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPledge reset all changes of the "pledge" edge.
func (m *RoomdetailMutation) ResetPledge() {
	m.pledge = nil
	m.clearedpledge = false
}

// SetPetruleID sets the petrule edge to Petrule by id.
func (m *RoomdetailMutation) SetPetruleID(id int) {
	m.petrule = &id
}

// ClearPetrule clears the petrule edge to Petrule.
func (m *RoomdetailMutation) ClearPetrule() {
	m.clearedpetrule = true
}

// PetruleCleared returns if the edge petrule was cleared.
func (m *RoomdetailMutation) PetruleCleared() bool {
	return m.clearedpetrule
}

// PetruleID returns the petrule id in the mutation.
func (m *RoomdetailMutation) PetruleID() (id int, exists bool) {
	if m.petrule != nil {
		return *m.petrule, true
	}
	return
}

// PetruleIDs returns the petrule ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PetruleID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) PetruleIDs() (ids []int) {
	if id := m.petrule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPetrule reset all changes of the "petrule" edge.
func (m *RoomdetailMutation) ResetPetrule() {
	m.petrule = nil
	m.clearedpetrule = false
}

// SetBedtypeID sets the bedtype edge to Bedtype by id.
func (m *RoomdetailMutation) SetBedtypeID(id int) {
	m.bedtype = &id
}

// ClearBedtype clears the bedtype edge to Bedtype.
func (m *RoomdetailMutation) ClearBedtype() {
	m.clearedbedtype = true
}

// BedtypeCleared returns if the edge bedtype was cleared.
func (m *RoomdetailMutation) BedtypeCleared() bool {
	return m.clearedbedtype
}

// BedtypeID returns the bedtype id in the mutation.
func (m *RoomdetailMutation) BedtypeID() (id int, exists bool) {
	if m.bedtype != nil {
		return *m.bedtype, true
	}
	return
}

// BedtypeIDs returns the bedtype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BedtypeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) BedtypeIDs() (ids []int) {
	if id := m.bedtype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBedtype reset all changes of the "bedtype" edge.
func (m *RoomdetailMutation) ResetBedtype() {
	m.bedtype = nil
	m.clearedbedtype = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *RoomdetailMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *RoomdetailMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *RoomdetailMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *RoomdetailMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *RoomdetailMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetStaytypeID sets the staytype edge to Staytype by id.
func (m *RoomdetailMutation) SetStaytypeID(id int) {
	m.staytype = &id
}

// ClearStaytype clears the staytype edge to Staytype.
func (m *RoomdetailMutation) ClearStaytype() {
	m.clearedstaytype = true
}

// StaytypeCleared returns if the edge staytype was cleared.
func (m *RoomdetailMutation) StaytypeCleared() bool {
	return m.clearedstaytype
}

// StaytypeID returns the staytype id in the mutation.
func (m *RoomdetailMutation) StaytypeID() (id int, exists bool) {
	if m.staytype != nil {
		return *m.staytype, true
	}
	return
}

// StaytypeIDs returns the staytype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StaytypeID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) StaytypeIDs() (ids []int) {
	if id := m.staytype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaytype reset all changes of the "staytype" edge.
func (m *RoomdetailMutation) ResetStaytype() {
	m.staytype = nil
	m.clearedstaytype = false
}

// SetRoomdetailsID sets the roomdetails edge to Lease by id.
func (m *RoomdetailMutation) SetRoomdetailsID(id int) {
	m.roomdetails = &id
}

// ClearRoomdetails clears the roomdetails edge to Lease.
func (m *RoomdetailMutation) ClearRoomdetails() {
	m.clearedroomdetails = true
}

// RoomdetailsCleared returns if the edge roomdetails was cleared.
func (m *RoomdetailMutation) RoomdetailsCleared() bool {
	return m.clearedroomdetails
}

// RoomdetailsID returns the roomdetails id in the mutation.
func (m *RoomdetailMutation) RoomdetailsID() (id int, exists bool) {
	if m.roomdetails != nil {
		return *m.roomdetails, true
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomdetailsID instead. It exists only for internal usage by the builders.
func (m *RoomdetailMutation) RoomdetailsIDs() (ids []int) {
	if id := m.roomdetails; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *RoomdetailMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.clearedroomdetails = false
}

// AddCleaningroomIDs adds the cleaningrooms edge to CleaningRoom by ids.
func (m *RoomdetailMutation) AddCleaningroomIDs(ids ...int) {
	if m.cleaningrooms == nil {
		m.cleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.cleaningrooms[ids[i]] = struct{}{}
	}
}

// RemoveCleaningroomIDs removes the cleaningrooms edge to CleaningRoom by ids.
func (m *RoomdetailMutation) RemoveCleaningroomIDs(ids ...int) {
	if m.removedcleaningrooms == nil {
		m.removedcleaningrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcleaningrooms[ids[i]] = struct{}{}
	}
}

// RemovedCleaningrooms returns the removed ids of cleaningrooms.
func (m *RoomdetailMutation) RemovedCleaningroomsIDs() (ids []int) {
	for id := range m.removedcleaningrooms {
		ids = append(ids, id)
	}
	return
}

// CleaningroomsIDs returns the cleaningrooms ids in the mutation.
func (m *RoomdetailMutation) CleaningroomsIDs() (ids []int) {
	for id := range m.cleaningrooms {
		ids = append(ids, id)
	}
	return
}

// ResetCleaningrooms reset all changes of the "cleaningrooms" edge.
func (m *RoomdetailMutation) ResetCleaningrooms() {
	m.cleaningrooms = nil
	m.removedcleaningrooms = nil
}

// Op returns the operation name.
func (m *RoomdetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Roomdetail).
func (m *RoomdetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomdetailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.roomnumber != nil {
		fields = append(fields, roomdetail.FieldRoomnumber)
	}
	if m.roomtypename != nil {
		fields = append(fields, roomdetail.FieldRoomtypename)
	}
	if m.roomprice != nil {
		fields = append(fields, roomdetail.FieldRoomprice)
	}
	if m.sleep != nil {
		fields = append(fields, roomdetail.FieldSleep)
	}
	if m.bed != nil {
		fields = append(fields, roomdetail.FieldBed)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomdetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomdetail.FieldRoomnumber:
		return m.Roomnumber()
	case roomdetail.FieldRoomtypename:
		return m.Roomtypename()
	case roomdetail.FieldRoomprice:
		return m.Roomprice()
	case roomdetail.FieldSleep:
		return m.Sleep()
	case roomdetail.FieldBed:
		return m.Bed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomdetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomdetail.FieldRoomnumber:
		return m.OldRoomnumber(ctx)
	case roomdetail.FieldRoomtypename:
		return m.OldRoomtypename(ctx)
	case roomdetail.FieldRoomprice:
		return m.OldRoomprice(ctx)
	case roomdetail.FieldSleep:
		return m.OldSleep(ctx)
	case roomdetail.FieldBed:
		return m.OldBed(ctx)
	}
	return nil, fmt.Errorf("unknown Roomdetail field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomdetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomdetail.FieldRoomnumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomnumber(v)
		return nil
	case roomdetail.FieldRoomtypename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomtypename(v)
		return nil
	case roomdetail.FieldRoomprice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomprice(v)
		return nil
	case roomdetail.FieldSleep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSleep(v)
		return nil
	case roomdetail.FieldBed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBed(v)
		return nil
	}
	return fmt.Errorf("unknown Roomdetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomdetailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomdetailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomdetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Roomdetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomdetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomdetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomdetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Roomdetail nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomdetailMutation) ResetField(name string) error {
	switch name {
	case roomdetail.FieldRoomnumber:
		m.ResetRoomnumber()
		return nil
	case roomdetail.FieldRoomtypename:
		m.ResetRoomtypename()
		return nil
	case roomdetail.FieldRoomprice:
		m.ResetRoomprice()
		return nil
	case roomdetail.FieldSleep:
		m.ResetSleep()
		return nil
	case roomdetail.FieldBed:
		m.ResetBed()
		return nil
	}
	return fmt.Errorf("unknown Roomdetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomdetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.pledge != nil {
		edges = append(edges, roomdetail.EdgePledge)
	}
	if m.petrule != nil {
		edges = append(edges, roomdetail.EdgePetrule)
	}
	if m.bedtype != nil {
		edges = append(edges, roomdetail.EdgeBedtype)
	}
	if m.employee != nil {
		edges = append(edges, roomdetail.EdgeEmployee)
	}
	if m.staytype != nil {
		edges = append(edges, roomdetail.EdgeStaytype)
	}
	if m.roomdetails != nil {
		edges = append(edges, roomdetail.EdgeRoomdetails)
	}
	if m.cleaningrooms != nil {
		edges = append(edges, roomdetail.EdgeCleaningrooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomdetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roomdetail.EdgePledge:
		if id := m.pledge; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgePetrule:
		if id := m.petrule; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeBedtype:
		if id := m.bedtype; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeStaytype:
		if id := m.staytype; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeRoomdetails:
		if id := m.roomdetails; id != nil {
			return []ent.Value{*id}
		}
	case roomdetail.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.cleaningrooms))
		for id := range m.cleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomdetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedcleaningrooms != nil {
		edges = append(edges, roomdetail.EdgeCleaningrooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomdetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case roomdetail.EdgeCleaningrooms:
		ids := make([]ent.Value, 0, len(m.removedcleaningrooms))
		for id := range m.removedcleaningrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomdetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedpledge {
		edges = append(edges, roomdetail.EdgePledge)
	}
	if m.clearedpetrule {
		edges = append(edges, roomdetail.EdgePetrule)
	}
	if m.clearedbedtype {
		edges = append(edges, roomdetail.EdgeBedtype)
	}
	if m.clearedemployee {
		edges = append(edges, roomdetail.EdgeEmployee)
	}
	if m.clearedstaytype {
		edges = append(edges, roomdetail.EdgeStaytype)
	}
	if m.clearedroomdetails {
		edges = append(edges, roomdetail.EdgeRoomdetails)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomdetailMutation) EdgeCleared(name string) bool {
	switch name {
	case roomdetail.EdgePledge:
		return m.clearedpledge
	case roomdetail.EdgePetrule:
		return m.clearedpetrule
	case roomdetail.EdgeBedtype:
		return m.clearedbedtype
	case roomdetail.EdgeEmployee:
		return m.clearedemployee
	case roomdetail.EdgeStaytype:
		return m.clearedstaytype
	case roomdetail.EdgeRoomdetails:
		return m.clearedroomdetails
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomdetailMutation) ClearEdge(name string) error {
	switch name {
	case roomdetail.EdgePledge:
		m.ClearPledge()
		return nil
	case roomdetail.EdgePetrule:
		m.ClearPetrule()
		return nil
	case roomdetail.EdgeBedtype:
		m.ClearBedtype()
		return nil
	case roomdetail.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case roomdetail.EdgeStaytype:
		m.ClearStaytype()
		return nil
	case roomdetail.EdgeRoomdetails:
		m.ClearRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Roomdetail unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomdetailMutation) ResetEdge(name string) error {
	switch name {
	case roomdetail.EdgePledge:
		m.ResetPledge()
		return nil
	case roomdetail.EdgePetrule:
		m.ResetPetrule()
		return nil
	case roomdetail.EdgeBedtype:
		m.ResetBedtype()
		return nil
	case roomdetail.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case roomdetail.EdgeStaytype:
		m.ResetStaytype()
		return nil
	case roomdetail.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	case roomdetail.EdgeCleaningrooms:
		m.ResetCleaningrooms()
		return nil
	}
	return fmt.Errorf("unknown Roomdetail edge %s", name)
}

// SituationMutation represents an operation that mutate the Situations
// nodes in the graph.
type SituationMutation struct {
	config
	op                Op
	typ               string
	id                *int
	situationname     *string
	clearedFields     map[string]struct{}
	situations        map[int]struct{}
	removedsituations map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Situation, error)
}

var _ ent.Mutation = (*SituationMutation)(nil)

// situationOption allows to manage the mutation configuration using functional options.
type situationOption func(*SituationMutation)

// newSituationMutation creates new mutation for $n.Name.
func newSituationMutation(c config, op Op, opts ...situationOption) *SituationMutation {
	m := &SituationMutation{
		config:        c,
		op:            op,
		typ:           TypeSituation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSituationID sets the id field of the mutation.
func withSituationID(id int) situationOption {
	return func(m *SituationMutation) {
		var (
			err   error
			once  sync.Once
			value *Situation
		)
		m.oldValue = func(ctx context.Context) (*Situation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Situation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSituation sets the old Situation of the mutation.
func withSituation(node *Situation) situationOption {
	return func(m *SituationMutation) {
		m.oldValue = func(context.Context) (*Situation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SituationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SituationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SituationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSituationname sets the situationname field.
func (m *SituationMutation) SetSituationname(s string) {
	m.situationname = &s
}

// Situationname returns the situationname value in the mutation.
func (m *SituationMutation) Situationname() (r string, exists bool) {
	v := m.situationname
	if v == nil {
		return
	}
	return *v, true
}

// OldSituationname returns the old situationname value of the Situation.
// If the Situation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SituationMutation) OldSituationname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSituationname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSituationname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSituationname: %w", err)
	}
	return oldValue.Situationname, nil
}

// ResetSituationname reset all changes of the "situationname" field.
func (m *SituationMutation) ResetSituationname() {
	m.situationname = nil
}

// AddSituationIDs adds the situations edge to Bill by ids.
func (m *SituationMutation) AddSituationIDs(ids ...int) {
	if m.situations == nil {
		m.situations = make(map[int]struct{})
	}
	for i := range ids {
		m.situations[ids[i]] = struct{}{}
	}
}

// RemoveSituationIDs removes the situations edge to Bill by ids.
func (m *SituationMutation) RemoveSituationIDs(ids ...int) {
	if m.removedsituations == nil {
		m.removedsituations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsituations[ids[i]] = struct{}{}
	}
}

// RemovedSituations returns the removed ids of situations.
func (m *SituationMutation) RemovedSituationsIDs() (ids []int) {
	for id := range m.removedsituations {
		ids = append(ids, id)
	}
	return
}

// SituationsIDs returns the situations ids in the mutation.
func (m *SituationMutation) SituationsIDs() (ids []int) {
	for id := range m.situations {
		ids = append(ids, id)
	}
	return
}

// ResetSituations reset all changes of the "situations" edge.
func (m *SituationMutation) ResetSituations() {
	m.situations = nil
	m.removedsituations = nil
}

// Op returns the operation name.
func (m *SituationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Situation).
func (m *SituationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SituationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.situationname != nil {
		fields = append(fields, situation.FieldSituationname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SituationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case situation.FieldSituationname:
		return m.Situationname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SituationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case situation.FieldSituationname:
		return m.OldSituationname(ctx)
	}
	return nil, fmt.Errorf("unknown Situation field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SituationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case situation.FieldSituationname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSituationname(v)
		return nil
	}
	return fmt.Errorf("unknown Situation field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SituationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SituationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SituationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Situation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SituationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SituationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SituationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Situation nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SituationMutation) ResetField(name string) error {
	switch name {
	case situation.FieldSituationname:
		m.ResetSituationname()
		return nil
	}
	return fmt.Errorf("unknown Situation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SituationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.situations != nil {
		edges = append(edges, situation.EdgeSituations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SituationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case situation.EdgeSituations:
		ids := make([]ent.Value, 0, len(m.situations))
		for id := range m.situations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SituationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsituations != nil {
		edges = append(edges, situation.EdgeSituations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SituationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case situation.EdgeSituations:
		ids := make([]ent.Value, 0, len(m.removedsituations))
		for id := range m.removedsituations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SituationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SituationMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SituationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Situation unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SituationMutation) ResetEdge(name string) error {
	switch name {
	case situation.EdgeSituations:
		m.ResetSituations()
		return nil
	}
	return fmt.Errorf("unknown Situation edge %s", name)
}

// StatusdMutation represents an operation that mutate the Statusds
// nodes in the graph.
type StatusdMutation struct {
	config
	op              Op
	typ             string
	id              *int
	statusdname     *string
	clearedFields   map[string]struct{}
	statusds        map[int]struct{}
	removedstatusds map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Statusd, error)
}

var _ ent.Mutation = (*StatusdMutation)(nil)

// statusdOption allows to manage the mutation configuration using functional options.
type statusdOption func(*StatusdMutation)

// newStatusdMutation creates new mutation for $n.Name.
func newStatusdMutation(c config, op Op, opts ...statusdOption) *StatusdMutation {
	m := &StatusdMutation{
		config:        c,
		op:            op,
		typ:           TypeStatusd,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusdID sets the id field of the mutation.
func withStatusdID(id int) statusdOption {
	return func(m *StatusdMutation) {
		var (
			err   error
			once  sync.Once
			value *Statusd
		)
		m.oldValue = func(ctx context.Context) (*Statusd, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statusd.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatusd sets the old Statusd of the mutation.
func withStatusd(node *Statusd) statusdOption {
	return func(m *StatusdMutation) {
		m.oldValue = func(context.Context) (*Statusd, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusdMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusdMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatusdMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatusdname sets the statusdname field.
func (m *StatusdMutation) SetStatusdname(s string) {
	m.statusdname = &s
}

// Statusdname returns the statusdname value in the mutation.
func (m *StatusdMutation) Statusdname() (r string, exists bool) {
	v := m.statusdname
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusdname returns the old statusdname value of the Statusd.
// If the Statusd object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusdMutation) OldStatusdname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusdname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusdname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusdname: %w", err)
	}
	return oldValue.Statusdname, nil
}

// ResetStatusdname reset all changes of the "statusdname" field.
func (m *StatusdMutation) ResetStatusdname() {
	m.statusdname = nil
}

// AddStatusdIDs adds the statusds edge to Deposit by ids.
func (m *StatusdMutation) AddStatusdIDs(ids ...int) {
	if m.statusds == nil {
		m.statusds = make(map[int]struct{})
	}
	for i := range ids {
		m.statusds[ids[i]] = struct{}{}
	}
}

// RemoveStatusdIDs removes the statusds edge to Deposit by ids.
func (m *StatusdMutation) RemoveStatusdIDs(ids ...int) {
	if m.removedstatusds == nil {
		m.removedstatusds = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatusds[ids[i]] = struct{}{}
	}
}

// RemovedStatusds returns the removed ids of statusds.
func (m *StatusdMutation) RemovedStatusdsIDs() (ids []int) {
	for id := range m.removedstatusds {
		ids = append(ids, id)
	}
	return
}

// StatusdsIDs returns the statusds ids in the mutation.
func (m *StatusdMutation) StatusdsIDs() (ids []int) {
	for id := range m.statusds {
		ids = append(ids, id)
	}
	return
}

// ResetStatusds reset all changes of the "statusds" edge.
func (m *StatusdMutation) ResetStatusds() {
	m.statusds = nil
	m.removedstatusds = nil
}

// Op returns the operation name.
func (m *StatusdMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statusd).
func (m *StatusdMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatusdMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.statusdname != nil {
		fields = append(fields, statusd.FieldStatusdname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatusdMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statusd.FieldStatusdname:
		return m.Statusdname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatusdMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statusd.FieldStatusdname:
		return m.OldStatusdname(ctx)
	}
	return nil, fmt.Errorf("unknown Statusd field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusdMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statusd.FieldStatusdname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusdname(v)
		return nil
	}
	return fmt.Errorf("unknown Statusd field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatusdMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatusdMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusdMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statusd numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatusdMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatusdMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusdMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statusd nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatusdMutation) ResetField(name string) error {
	switch name {
	case statusd.FieldStatusdname:
		m.ResetStatusdname()
		return nil
	}
	return fmt.Errorf("unknown Statusd field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatusdMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.statusds != nil {
		edges = append(edges, statusd.EdgeStatusds)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatusdMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statusd.EdgeStatusds:
		ids := make([]ent.Value, 0, len(m.statusds))
		for id := range m.statusds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatusdMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatusds != nil {
		edges = append(edges, statusd.EdgeStatusds)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatusdMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statusd.EdgeStatusds:
		ids := make([]ent.Value, 0, len(m.removedstatusds))
		for id := range m.removedstatusds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatusdMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatusdMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatusdMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statusd unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatusdMutation) ResetEdge(name string) error {
	switch name {
	case statusd.EdgeStatusds:
		m.ResetStatusds()
		return nil
	}
	return fmt.Errorf("unknown Statusd edge %s", name)
}

// StaytypeMutation represents an operation that mutate the Staytypes
// nodes in the graph.
type StaytypeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	staytype           *string
	clearedFields      map[string]struct{}
	roomdetails        map[int]struct{}
	removedroomdetails map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Staytype, error)
}

var _ ent.Mutation = (*StaytypeMutation)(nil)

// staytypeOption allows to manage the mutation configuration using functional options.
type staytypeOption func(*StaytypeMutation)

// newStaytypeMutation creates new mutation for $n.Name.
func newStaytypeMutation(c config, op Op, opts ...staytypeOption) *StaytypeMutation {
	m := &StaytypeMutation{
		config:        c,
		op:            op,
		typ:           TypeStaytype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaytypeID sets the id field of the mutation.
func withStaytypeID(id int) staytypeOption {
	return func(m *StaytypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Staytype
		)
		m.oldValue = func(ctx context.Context) (*Staytype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staytype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaytype sets the old Staytype of the mutation.
func withStaytype(node *Staytype) staytypeOption {
	return func(m *StaytypeMutation) {
		m.oldValue = func(context.Context) (*Staytype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaytypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaytypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StaytypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStaytype sets the staytype field.
func (m *StaytypeMutation) SetStaytype(s string) {
	m.staytype = &s
}

// Staytype returns the staytype value in the mutation.
func (m *StaytypeMutation) Staytype() (r string, exists bool) {
	v := m.staytype
	if v == nil {
		return
	}
	return *v, true
}

// OldStaytype returns the old staytype value of the Staytype.
// If the Staytype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StaytypeMutation) OldStaytype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStaytype is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStaytype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaytype: %w", err)
	}
	return oldValue.Staytype, nil
}

// ResetStaytype reset all changes of the "staytype" field.
func (m *StaytypeMutation) ResetStaytype() {
	m.staytype = nil
}

// AddRoomdetailIDs adds the roomdetails edge to Roomdetail by ids.
func (m *StaytypeMutation) AddRoomdetailIDs(ids ...int) {
	if m.roomdetails == nil {
		m.roomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.roomdetails[ids[i]] = struct{}{}
	}
}

// RemoveRoomdetailIDs removes the roomdetails edge to Roomdetail by ids.
func (m *StaytypeMutation) RemoveRoomdetailIDs(ids ...int) {
	if m.removedroomdetails == nil {
		m.removedroomdetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroomdetails[ids[i]] = struct{}{}
	}
}

// RemovedRoomdetails returns the removed ids of roomdetails.
func (m *StaytypeMutation) RemovedRoomdetailsIDs() (ids []int) {
	for id := range m.removedroomdetails {
		ids = append(ids, id)
	}
	return
}

// RoomdetailsIDs returns the roomdetails ids in the mutation.
func (m *StaytypeMutation) RoomdetailsIDs() (ids []int) {
	for id := range m.roomdetails {
		ids = append(ids, id)
	}
	return
}

// ResetRoomdetails reset all changes of the "roomdetails" edge.
func (m *StaytypeMutation) ResetRoomdetails() {
	m.roomdetails = nil
	m.removedroomdetails = nil
}

// Op returns the operation name.
func (m *StaytypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Staytype).
func (m *StaytypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StaytypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.staytype != nil {
		fields = append(fields, staytype.FieldStaytype)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StaytypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staytype.FieldStaytype:
		return m.Staytype()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StaytypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staytype.FieldStaytype:
		return m.OldStaytype(ctx)
	}
	return nil, fmt.Errorf("unknown Staytype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StaytypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staytype.FieldStaytype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaytype(v)
		return nil
	}
	return fmt.Errorf("unknown Staytype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StaytypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StaytypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StaytypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Staytype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StaytypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StaytypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaytypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Staytype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StaytypeMutation) ResetField(name string) error {
	switch name {
	case staytype.FieldStaytype:
		m.ResetStaytype()
		return nil
	}
	return fmt.Errorf("unknown Staytype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StaytypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roomdetails != nil {
		edges = append(edges, staytype.EdgeRoomdetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StaytypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staytype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.roomdetails))
		for id := range m.roomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StaytypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroomdetails != nil {
		edges = append(edges, staytype.EdgeRoomdetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StaytypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case staytype.EdgeRoomdetails:
		ids := make([]ent.Value, 0, len(m.removedroomdetails))
		for id := range m.removedroomdetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StaytypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StaytypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StaytypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Staytype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StaytypeMutation) ResetEdge(name string) error {
	switch name {
	case staytype.EdgeRoomdetails:
		m.ResetRoomdetails()
		return nil
	}
	return fmt.Errorf("unknown Staytype edge %s", name)
}

// WifiMutation represents an operation that mutate the Wifis
// nodes in the graph.
type WifiMutation struct {
	config
	op            Op
	typ           string
	id            *int
	wifiname      *string
	clearedFields map[string]struct{}
	wifis         map[int]struct{}
	removedwifis  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Wifi, error)
}

var _ ent.Mutation = (*WifiMutation)(nil)

// wifiOption allows to manage the mutation configuration using functional options.
type wifiOption func(*WifiMutation)

// newWifiMutation creates new mutation for $n.Name.
func newWifiMutation(c config, op Op, opts ...wifiOption) *WifiMutation {
	m := &WifiMutation{
		config:        c,
		op:            op,
		typ:           TypeWifi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWifiID sets the id field of the mutation.
func withWifiID(id int) wifiOption {
	return func(m *WifiMutation) {
		var (
			err   error
			once  sync.Once
			value *Wifi
		)
		m.oldValue = func(ctx context.Context) (*Wifi, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wifi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWifi sets the old Wifi of the mutation.
func withWifi(node *Wifi) wifiOption {
	return func(m *WifiMutation) {
		m.oldValue = func(context.Context) (*Wifi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WifiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WifiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WifiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWifiname sets the wifiname field.
func (m *WifiMutation) SetWifiname(s string) {
	m.wifiname = &s
}

// Wifiname returns the wifiname value in the mutation.
func (m *WifiMutation) Wifiname() (r string, exists bool) {
	v := m.wifiname
	if v == nil {
		return
	}
	return *v, true
}

// OldWifiname returns the old wifiname value of the Wifi.
// If the Wifi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WifiMutation) OldWifiname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWifiname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWifiname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWifiname: %w", err)
	}
	return oldValue.Wifiname, nil
}

// ResetWifiname reset all changes of the "wifiname" field.
func (m *WifiMutation) ResetWifiname() {
	m.wifiname = nil
}

// AddWifiIDs adds the wifis edge to Lease by ids.
func (m *WifiMutation) AddWifiIDs(ids ...int) {
	if m.wifis == nil {
		m.wifis = make(map[int]struct{})
	}
	for i := range ids {
		m.wifis[ids[i]] = struct{}{}
	}
}

// RemoveWifiIDs removes the wifis edge to Lease by ids.
func (m *WifiMutation) RemoveWifiIDs(ids ...int) {
	if m.removedwifis == nil {
		m.removedwifis = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwifis[ids[i]] = struct{}{}
	}
}

// RemovedWifis returns the removed ids of wifis.
func (m *WifiMutation) RemovedWifisIDs() (ids []int) {
	for id := range m.removedwifis {
		ids = append(ids, id)
	}
	return
}

// WifisIDs returns the wifis ids in the mutation.
func (m *WifiMutation) WifisIDs() (ids []int) {
	for id := range m.wifis {
		ids = append(ids, id)
	}
	return
}

// ResetWifis reset all changes of the "wifis" edge.
func (m *WifiMutation) ResetWifis() {
	m.wifis = nil
	m.removedwifis = nil
}

// Op returns the operation name.
func (m *WifiMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Wifi).
func (m *WifiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WifiMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.wifiname != nil {
		fields = append(fields, wifi.FieldWifiname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WifiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wifi.FieldWifiname:
		return m.Wifiname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WifiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wifi.FieldWifiname:
		return m.OldWifiname(ctx)
	}
	return nil, fmt.Errorf("unknown Wifi field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WifiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wifi.FieldWifiname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWifiname(v)
		return nil
	}
	return fmt.Errorf("unknown Wifi field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WifiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WifiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WifiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Wifi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WifiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WifiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WifiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wifi nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WifiMutation) ResetField(name string) error {
	switch name {
	case wifi.FieldWifiname:
		m.ResetWifiname()
		return nil
	}
	return fmt.Errorf("unknown Wifi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WifiMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.wifis != nil {
		edges = append(edges, wifi.EdgeWifis)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WifiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wifi.EdgeWifis:
		ids := make([]ent.Value, 0, len(m.wifis))
		for id := range m.wifis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WifiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedwifis != nil {
		edges = append(edges, wifi.EdgeWifis)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WifiMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wifi.EdgeWifis:
		ids := make([]ent.Value, 0, len(m.removedwifis))
		for id := range m.removedwifis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WifiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WifiMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WifiMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Wifi unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WifiMutation) ResetEdge(name string) error {
	switch name {
	case wifi.EdgeWifis:
		m.ResetWifis()
		return nil
	}
	return fmt.Errorf("unknown Wifi edge %s", name)
}
